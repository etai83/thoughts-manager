{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/tokenizer/languages.ts"],"sourcesContent":["export const STEMMERS: Record<string, string> = {\n  arabic: 'ar',\n  armenian: 'am',\n  bulgarian: 'bg',\n  danish: 'dk',\n  dutch: 'nl',\n  english: 'en',\n  finnish: 'fi',\n  french: 'fr',\n  german: 'de',\n  greek: 'gr',\n  hungarian: 'hu',\n  indian: 'in',\n  indonesian: 'id',\n  irish: 'ie',\n  italian: 'it',\n  lithuanian: 'lt',\n  nepali: 'np',\n  norwegian: 'no',\n  portuguese: 'pt',\n  romanian: 'ro',\n  russian: 'ru',\n  serbian: 'rs',\n  slovenian: 'ru',\n  spanish: 'es',\n  swedish: 'se',\n  tamil: 'ta',\n  turkish: 'tr',\n  ukrainian: 'uk',\n  sanskrit: 'sk'\n}\n\nexport const SPLITTERS: Record<Language, RegExp> = {\n  dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,\n  italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,\n  norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,\n  portuguese: /[^a-z0-9à-úÀ-Ú]/gim,\n  russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,\n  spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,\n  swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,\n  german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,\n  finnish: /[^a-z0-9äöÄÖ]+/gim,\n  danish: /[^a-z0-9æøåÆØÅ]+/gim,\n  hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,\n  romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,\n  serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,\n  turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,\n  lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,\n  arabic: /[^a-z0-9أ-ي]+/gim,\n  nepali: /[^a-z0-9अ-ह]+/gim,\n  irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,\n  indian: /[^a-z0-9अ-ह]+/gim,\n  armenian: /[^a-z0-9ա-ֆ]+/gim,\n  greek: /[^a-z0-9α-ωά-ώ]+/gim,\n  indonesian: /[^a-z0-9]+/gim,\n  ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,\n  slovenian: /[^a-z0-9čžšČŽŠ]+/gim,\n  bulgarian: /[^a-z0-9а-яА-Я]+/gim,\n  tamil: /[^a-z0-9அ-ஹ]+/gim,\n  sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim\n}\n\nexport const SUPPORTED_LANGUAGES = Object.keys(STEMMERS)\n\nexport function getLocale(language: string | undefined) {\n  return language !== undefined && SUPPORTED_LANGUAGES.includes(language) ? STEMMERS[language] : undefined\n}\n\nexport type Language = (typeof SUPPORTED_LANGUAGES)[number]\n"],"names":["STEMMERS","arabic","armenian","bulgarian","danish","dutch","english","finnish","french","german","greek","hungarian","indian","indonesian","irish","italian","lithuanian","nepali","norwegian","portuguese","romanian","russian","serbian","slovenian","spanish","swedish","tamil","turkish","ukrainian","sanskrit","SPLITTERS","SUPPORTED_LANGUAGES","Object","keys","getLocale","language","undefined","includes"],"mappings":";;;;;;;;;;AAAO,MAAMA,WAAmC;IAC9CC,QAAQ;IACRC,UAAU;IACVC,WAAW;IACXC,QAAQ;IACRC,OAAO;IACPC,SAAS;IACTC,SAAS;IACTC,QAAQ;IACRC,QAAQ;IACRC,OAAO;IACPC,WAAW;IACXC,QAAQ;IACRC,YAAY;IACZC,OAAO;IACPC,SAAS;IACTC,YAAY;IACZC,QAAQ;IACRC,WAAW;IACXC,YAAY;IACZC,UAAU;IACVC,SAAS;IACTC,SAAS;IACTC,WAAW;IACXC,SAAS;IACTC,SAAS;IACTC,OAAO;IACPC,SAAS;IACTC,WAAW;IACXC,UAAU;AACZ,EAAC;AAEM,MAAMC,YAAsC;IACjDzB,OAAO;IACPC,SAAS;IACTE,QAAQ;IACRO,SAAS;IACTG,WAAW;IACXC,YAAY;IACZE,SAAS;IACTG,SAAS;IACTC,SAAS;IACThB,QAAQ;IACRF,SAAS;IACTH,QAAQ;IACRO,WAAW;IACXS,UAAU;IACVE,SAAS;IACTK,SAAS;IACTX,YAAY;IACZf,QAAQ;IACRgB,QAAQ;IACRH,OAAO;IACPF,QAAQ;IACRV,UAAU;IACVQ,OAAO;IACPG,YAAY;IACZe,WAAW;IACXL,WAAW;IACXpB,WAAW;IACXuB,OAAO;IACPG,UAAU;AACZ,EAAC;AAEM,MAAME,sBAAsBC,OAAOC,IAAI,CAACjC,UAAS;AAEjD,SAASkC,UAAUC,QAA4B,EAAE;IACtD,OAAOA,aAAaC,aAAaL,oBAAoBM,QAAQ,CAACF,YAAYnC,QAAQ,CAACmC,SAAS,GAAGC,SAAS;AAC1G,CAAC"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/utils.ts"],"sourcesContent":["import type { AnyDocument, GeosearchDistanceUnit, Results, SearchableValue, TokenScore } from './types.js'\nimport { createError } from './errors.js'\n\nconst baseId = Date.now().toString().slice(5)\nlet lastId = 0\n\nconst k = 1024\nconst nano = BigInt(1e3)\nconst milli = BigInt(1e6)\nconst second = BigInt(1e9)\n\nexport const isServer = typeof window === 'undefined'\n\n/**\n * This value can be increased up to 100_000\n * But i don't know if this value change from nodejs to nodejs\n * So I will keep a safer value here.\n */\nexport const MAX_ARGUMENT_FOR_STACK = 65535\n\n/**\n * This method is needed to used because of issues like: https://github.com/askorama/orama/issues/301\n * that issue is caused because the array that is pushed is huge (>100k)\n *\n * @example\n * ```ts\n * safeArrayPush(myArray, [1, 2])\n * ```\n */\nexport function safeArrayPush<T>(arr: T[], newArr: T[]): void {\n  if (newArr.length < MAX_ARGUMENT_FOR_STACK) {\n    Array.prototype.push.apply(arr, newArr)\n  } else {\n    const newArrLength = newArr.length\n    for (let i = 0; i < newArrLength; i += MAX_ARGUMENT_FOR_STACK) {\n      Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK))\n    }\n  }\n}\n\nexport function sprintf(template: string, ...args: Array<string | number>): string {\n  return template.replace(\n    /%(?:(?<position>\\d+)\\$)?(?<width>-?\\d*\\.?\\d*)(?<type>[dfs])/g,\n    function (...replaceArgs: Array<string | number | Record<string, string>>): string {\n      const groups = replaceArgs[replaceArgs.length - 1] as Record<string, string>\n      const { width: rawWidth, type, position } = groups\n\n      const replacement = position ? args[Number.parseInt(position) - 1]! : args.shift()!\n      const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth)\n\n      switch (type) {\n        case 'd':\n          return replacement.toString().padStart(width, '0')\n        case 'f': {\n          let value = replacement\n          const [padding, precision] = rawWidth.split('.').map((w) => Number.parseFloat(w))\n\n          if (typeof precision === 'number' && precision >= 0) {\n            value = (value as number).toFixed(precision)\n          }\n\n          return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString()\n        }\n        case 's':\n          return width < 0\n            ? (replacement as string).toString().padEnd(-width, ' ')\n            : (replacement as string).toString().padStart(width, ' ')\n\n        default:\n          return replacement as string\n      }\n    }\n  )\n}\n\nexport async function formatBytes(bytes: number, decimals = 2): Promise<string> {\n  if (bytes === 0) {\n    return '0 Bytes'\n  }\n  const dm = decimals < 0 ? 0 : decimals\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`\n}\n\nexport function isInsideWebWorker(): boolean {\n  // @ts-expect-error - WebWorker global scope\n  return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\n}\n\nexport function isInsideNode(): boolean {\n  return typeof process !== 'undefined' && process.release && process.release.name === 'node'\n}\n\nexport function getNanosecondTimeViaPerformance() {\n  return BigInt(Math.floor(performance.now() * 1e6))\n}\n\nexport async function formatNanoseconds(value: number | bigint): Promise<string> {\n  if (typeof value === 'number') {\n    value = BigInt(value)\n  }\n\n  if (value < nano) {\n    return `${value}ns`\n  } else if (value < milli) {\n    return `${value / nano}μs`\n  } else if (value < second) {\n    return `${value / milli}ms`\n  }\n\n  return `${value / second}s`\n}\n\n// TODO: none of these operations is async. Should we change the signature of this function?\nexport async function getNanosecondsTime(): Promise<bigint> {\n  if (isInsideWebWorker()) {\n    return getNanosecondTimeViaPerformance()\n  }\n\n  if (isInsideNode()) {\n    return process.hrtime.bigint()\n  }\n\n  if (typeof process !== 'undefined' && typeof process?.hrtime?.bigint === 'function') {\n    return process.hrtime.bigint()\n  }\n\n  if (typeof performance !== 'undefined') {\n    return getNanosecondTimeViaPerformance()\n  }\n\n  // @todo: fallback to V8 native method to get microtime\n  return BigInt(0)\n}\n\nexport async function uniqueId(): Promise<string> {\n  return `${baseId}-${lastId++}`\n}\n\nexport function getOwnProperty<T = unknown>(object: Record<string, T>, property: string): T | undefined {\n  // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n  if (Object.hasOwn === undefined) {\n    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined\n  }\n\n  return Object.hasOwn(object, property) ? object[property] : undefined\n}\n\nexport function getTokenFrequency(token: string, tokens: string[]): number {\n  let count = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      count++\n    }\n  }\n\n  return count\n}\n\nexport function insertSortedValue(\n  arr: TokenScore[],\n  el: TokenScore,\n  compareFn = sortTokenScorePredicate\n): TokenScore[] {\n  let low = 0\n  let high = arr.length\n  let mid\n\n  while (low < high) {\n    mid = (low + high) >>> 1\n    if (compareFn(el, arr[mid]) < 0) {\n      high = mid\n    } else {\n      low = mid + 1\n    }\n  }\n\n  arr.splice(low, 0, el)\n\n  return arr\n}\n\nexport function sortTokenScorePredicate(a: TokenScore, b: TokenScore): number {\n  if (b[1] === a[1]) {\n    return a[0] - b[0]\n  }\n\n  return b[1] - a[1]\n}\n\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect<T>(arrays: Array<readonly T[]>): T[] {\n  if (arrays.length === 0) {\n    return []\n  } else if (arrays.length === 1) {\n    return arrays[0] as T[]\n  }\n\n  for (let i = 1; i < arrays.length; i++) {\n    if (arrays[i].length < arrays[0].length) {\n      const tmp = arrays[0]\n      arrays[0] = arrays[i]\n      arrays[i] = tmp\n    }\n  }\n\n  const set = new Map()\n  for (const elem of arrays[0]) {\n    set.set(elem, 1)\n  }\n  for (let i = 1; i < arrays.length; i++) {\n    let found = 0\n    for (const elem of arrays[i]) {\n      const count = set.get(elem)\n      if (count === i) {\n        set.set(elem, count + 1)\n        found++\n      }\n    }\n    if (found === 0) return []\n  }\n\n  return arrays[0].filter((e) => {\n    const count = set.get(e)\n    if (count !== undefined) set.set(e, 0)\n    return count === arrays.length\n  })\n}\n\nexport async function getDocumentProperties(\n  doc: AnyDocument,\n  paths: string[]\n): Promise<Record<string, SearchableValue>> {\n  const properties: Record<string, SearchableValue> = {}\n\n  const pathsLength = paths.length\n  for (let i = 0; i < pathsLength; i++) {\n    const path = paths[i]\n    const pathTokens = path.split('.')\n\n    let current: SearchableValue | AnyDocument | undefined = doc\n    const pathTokensLength = pathTokens.length\n    for (let j = 0; j < pathTokensLength; j++) {\n      current = current[pathTokens[j]!]\n\n      // We found an object but we were supposed to be done\n      if (typeof current === 'object') {\n        if (\n          current !== null &&\n          'lat' in current &&\n          'lon' in current &&\n          typeof current.lat === 'number' &&\n          typeof current.lon === 'number'\n        ) {\n          current = properties[path] = current as SearchableValue\n          break\n        } else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {\n          current = undefined\n          break\n        }\n      } else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {\n        // We can't recurse anymore but we were supposed to\n        current = undefined\n        break\n      }\n    }\n\n    if (typeof current !== 'undefined') {\n      properties[path] = current as SearchableValue\n    }\n  }\n\n  return properties\n}\n\nexport async function getNested<T = SearchableValue>(obj: object, path: string): Promise<T | undefined> {\n  const props = await getDocumentProperties(obj as AnyDocument, [path])\n\n  return props[path] as T | undefined\n}\n\nexport function flattenObject(obj: object, prefix = ''): AnyDocument {\n  const result: AnyDocument = {}\n\n  for (const key in obj) {\n    const prop = `${prefix}${key}`\n    const objKey = (obj as AnyDocument)[key]\n\n    if (typeof objKey === 'object' && objKey !== null) {\n      Object.assign(result, flattenObject(objKey, `${prop}.`))\n    } else {\n      result[prop] = objKey\n    }\n  }\n  return result\n}\n\nconst mapDistanceToMeters = {\n  cm: 0.01,\n  m: 1,\n  km: 1000,\n  ft: 0.3048,\n  yd: 0.9144,\n  mi: 1609.344\n}\n\nexport function convertDistanceToMeters(distance: number, unit: GeosearchDistanceUnit): number {\n  const ratio = mapDistanceToMeters[unit]\n\n  if (ratio === undefined) {\n    throw new Error(createError('INVALID_DISTANCE_SUFFIX', distance).message)\n  }\n\n  return distance * ratio\n}\n\nexport function removeVectorsFromHits(searchResult: Results<AnyDocument>, vectorProperties: string[]): void {\n  searchResult.hits = searchResult.hits.map((result) => ({\n    ...result,\n    document: {\n      ...result.document,\n      // Remove embeddings from the result\n      ...vectorProperties.reduce((acc, prop) => {\n        const path = prop.split('.')\n        const lastKey = path.pop()!\n        let obj = acc\n        for (const key of path) {\n          obj[key] = obj[key] ?? {}\n          obj = obj[key] as any\n        }\n        obj[lastKey] = null\n        return acc\n      }, result.document)\n    }\n  }))\n}\n"],"names":["createError","baseId","Date","now","toString","slice","lastId","k","nano","BigInt","milli","second","isServer","window","MAX_ARGUMENT_FOR_STACK","safeArrayPush","arr","newArr","length","Array","prototype","push","apply","newArrLength","i","sprintf","template","args","replace","replaceArgs","groups","width","rawWidth","type","position","replacement","Number","parseInt","shift","padStart","value","padding","precision","split","map","w","parseFloat","toFixed","padEnd","formatBytes","bytes","decimals","dm","sizes","Math","floor","log","pow","isInsideWebWorker","WorkerGlobalScope","self","isInsideNode","process","release","name","getNanosecondTimeViaPerformance","performance","formatNanoseconds","getNanosecondsTime","hrtime","bigint","uniqueId","getOwnProperty","object","property","Object","hasOwn","undefined","hasOwnProperty","call","getTokenFrequency","token","tokens","count","t","insertSortedValue","el","compareFn","sortTokenScorePredicate","low","high","mid","splice","a","b","intersect","arrays","tmp","set","Map","elem","found","get","filter","e","getDocumentProperties","doc","paths","properties","pathsLength","path","pathTokens","current","pathTokensLength","j","lat","lon","isArray","getNested","obj","props","flattenObject","prefix","result","key","prop","objKey","assign","mapDistanceToMeters","cm","m","km","ft","yd","mi","convertDistanceToMeters","distance","unit","ratio","Error","message","removeVectorsFromHits","searchResult","vectorProperties","hits","document","reduce","acc","lastKey","pop"],"mappings":"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"}},
    {"offset": {"line": 396, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/errors.ts"],"sourcesContent":["import { SUPPORTED_LANGUAGES } from './components/tokenizer/languages.js'\nimport { sprintf } from './utils.js'\n\nconst allLanguages = SUPPORTED_LANGUAGES.join('\\n - ')\n\nconst errors = {\n  NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',\n  LANGUAGE_NOT_SUPPORTED: `Language \"%s\" is not supported.\\nSupported languages are:\\n - ${allLanguages}`,\n  INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,\n  MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the \"%s\" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/open-source/text-analysis/stemming for more information.`,\n  CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',\n  UNSUPPORTED_COMPONENT: `Unsupported component \"%s\".`,\n  COMPONENT_MUST_BE_FUNCTION: `The component \"%s\" must be a function.`,\n  COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component \"%s\" must be a function or an array of functions.`,\n  INVALID_SCHEMA_TYPE: `Unsupported schema type \"%s\" at \"%s\". Expected \"string\", \"boolean\" or \"number\" or array of them.`,\n  DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type \"string\". Got \"%s\" instead.`,\n  DOCUMENT_ALREADY_EXISTS: `A document with id \"%s\" already exists.`,\n  DOCUMENT_DOES_NOT_EXIST: `A document with id \"%s\" does not exists.`,\n  MISSING_DOCUMENT_PROPERTY: `Missing searchable property \"%s\".`,\n  INVALID_DOCUMENT_PROPERTY: `Invalid document property \"%s\": expected \"%s\", got \"%s\"`,\n  UNKNOWN_INDEX: `Invalid property name \"%s\". Expected a wildcard string (\"*\") or array containing one of the following properties: %s`,\n  INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,\n  INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,\n  SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on \"%s\" property.`,\n  INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type \"%s\" at \"%s\". Expected \"string\" or \"number\".`,\n  CANNOT_SORT_BY_ARRAY: `Cannot configure sort for \"%s\" because it is an array (%s).`,\n  UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field \"%s\". Allowed fields: %s`,\n  SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.oramasearch for more information.`,\n  UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property \"%s\".`,\n  INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property \"%s\". Allowed types: \"%s\", but given \"%s\".`,\n  UNKNOWN_FILTER_PROPERTY: `Unknown filter property \"%s\".`,\n  INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got \"%s\" instead.`,\n  INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got \"%s\" instead.`,\n  INVALID_INPUT_VECTOR: `Property \"%s\" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,\n  WRONG_SEARCH_PROPERTY_TYPE: `Property \"%s\" is not searchable. Only \"string\" properties are searchable.`,\n  FACET_NOT_SUPPORTED: `Facet doens't support the type \"%s\".`,\n  INVALID_DISTANCE_SUFFIX: `Invalid distance suffix \"%s\". Valid suffixes are: cm, m, km, mi, yd, ft.`,\n  INVALID_SEARCH_MODE: `Invalid search mode \"%s\". Valid modes are: \"fulltext\", \"vector\", \"hybrid\".`,\n  MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,\n  MISSING_TERM: `\"term\" is a required parameter when performing hybrid search. Please provide a search term.`,\n  INVALID_VECTOR_INPUT: `Invalid \"vector\" property. Expected an object with \"value\" and \"property\" properties, but got \"%s\" instead.`,\n  PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`\n}\n\nexport type ErrorCode = keyof typeof errors\n\nexport interface OramaError extends Error {\n  code: string\n}\n\nexport function createError(code: ErrorCode, ...args: Array<string | number>): OramaError {\n  const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args)) as OramaError\n  error.code = code\n  if ('captureStackTrace' in Error.prototype) {\n    Error.captureStackTrace(error)\n  }\n\n  return error\n}\n"],"names":["SUPPORTED_LANGUAGES","sprintf","allLanguages","join","errors","NO_LANGUAGE_WITH_CUSTOM_TOKENIZER","LANGUAGE_NOT_SUPPORTED","INVALID_STEMMER_FUNCTION_TYPE","MISSING_STEMMER","CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY","UNSUPPORTED_COMPONENT","COMPONENT_MUST_BE_FUNCTION","COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS","INVALID_SCHEMA_TYPE","DOCUMENT_ID_MUST_BE_STRING","DOCUMENT_ALREADY_EXISTS","DOCUMENT_DOES_NOT_EXIST","MISSING_DOCUMENT_PROPERTY","INVALID_DOCUMENT_PROPERTY","UNKNOWN_INDEX","INVALID_BOOST_VALUE","INVALID_FILTER_OPERATION","SCHEMA_VALIDATION_FAILURE","INVALID_SORT_SCHEMA_TYPE","CANNOT_SORT_BY_ARRAY","UNABLE_TO_SORT_ON_UNKNOWN_FIELD","SORT_DISABLED","UNKNOWN_GROUP_BY_PROPERTY","INVALID_GROUP_BY_PROPERTY","UNKNOWN_FILTER_PROPERTY","INVALID_VECTOR_SIZE","INVALID_VECTOR_VALUE","INVALID_INPUT_VECTOR","WRONG_SEARCH_PROPERTY_TYPE","FACET_NOT_SUPPORTED","INVALID_DISTANCE_SUFFIX","INVALID_SEARCH_MODE","MISSING_VECTOR_AND_SECURE_PROXY","MISSING_TERM","INVALID_VECTOR_INPUT","PLUGIN_CRASHED","createError","code","args","error","Error","prototype","captureStackTrace"],"mappings":";;;;AAAA,SAASA,mBAAmB,QAAQ,sCAAqC;AACzE,SAASC,OAAO,QAAQ,aAAY;;;AAEpC,MAAMC,eAAeF,0MAAAA,CAAoBG,IAAI,CAAC;AAE9C,MAAMC,SAAS;IACbC,mCAAmC;IACnCC,wBAAwB,CAAC,8DAA8D,EAAEJ,aAAa,CAAC;IACvGK,+BAA+B,CAAC,2CAA2C,CAAC;IAC5EC,iBAAiB,CAAC,gRAAgR,CAAC;IACnSC,6CAA6C;IAC7CC,uBAAuB,CAAC,2BAA2B,CAAC;IACpDC,4BAA4B,CAAC,sCAAsC,CAAC;IACpEC,+CAA+C,CAAC,+DAA+D,CAAC;IAChHC,qBAAqB,CAAC,gGAAgG,CAAC;IACvHC,4BAA4B,CAAC,uDAAuD,CAAC;IACrFC,yBAAyB,CAAC,uCAAuC,CAAC;IAClEC,yBAAyB,CAAC,wCAAwC,CAAC;IACnEC,2BAA2B,CAAC,iCAAiC,CAAC;IAC9DC,2BAA2B,CAAC,uDAAuD,CAAC;IACpFC,eAAe,CAAC,oHAAoH,CAAC;IACrIC,qBAAqB,CAAC,0DAA0D,CAAC;IACjFC,0BAA0B,CAAC,4DAA4D,CAAC;IACxFC,2BAA2B,CAAC,sEAAsE,CAAC;IACnGC,0BAA0B,CAAC,yEAAyE,CAAC;IACrGC,sBAAsB,CAAC,2DAA2D,CAAC;IACnFC,iCAAiC,CAAC,wDAAwD,CAAC;IAC3FC,eAAe,CAAC,iGAAiG,CAAC;IAClHC,2BAA2B,CAAC,8BAA8B,CAAC;IAC3DC,2BAA2B,CAAC,mEAAmE,CAAC;IAChGC,yBAAyB,CAAC,6BAA6B,CAAC;IACxDC,qBAAqB,CAAC,8DAA8D,CAAC;IACrFC,sBAAsB,CAAC,+DAA+D,CAAC;IACvFC,sBAAsB,CAAC,uPAAuP,CAAC;IAC/QC,4BAA4B,CAAC,yEAAyE,CAAC;IACvGC,qBAAqB,CAAC,oCAAoC,CAAC;IAC3DC,yBAAyB,CAAC,wEAAwE,CAAC;IACnGC,qBAAqB,CAAC,0EAA0E,CAAC;IACjGC,iCAAiC,CAAC,+IAA+I,CAAC;IAClLC,cAAc,CAAC,2FAA2F,CAAC;IAC3GC,sBAAsB,CAAC,2GAA2G,CAAC;IACnIC,gBAAgB,CAAC,4FAA4F,CAAC;AAChH;AAQO,SAASC,YAAYC,IAAe,EAAE,GAAGC,IAA4B,EAAc;IACxF,MAAMC,QAAQ,IAAIC,UAAM5C,+JAAAA,EAAQG,MAAM,CAACsC,KAAK,IAAI,CAAC,8BAA8B,EAAEA,KAAK,CAAC,KAAKC;IAC5FC,MAAMF,IAAI,GAAGA;IACb,IAAI,uBAAuBG,MAAMC,SAAS,EAAE;QAC1CD,MAAME,iBAAiB,CAACH;IAC1B,CAAC;IAED,OAAOA;AACT,CAAC"}},
    {"offset": {"line": 455, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/defaults.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { Point } from '../trees/bkd.js'\nimport {\n  AnyDocument,\n  AnyOrama,\n  ArraySearchableType,\n  ElapsedTime,\n  ScalarSearchableType,\n  SearchableType,\n  TypedDocument,\n  Vector\n} from '../types.js'\nimport { formatNanoseconds, uniqueId } from '../utils.js'\n\nexport { getDocumentProperties } from '../utils.js'\n\nexport async function formatElapsedTime(n: bigint): Promise<ElapsedTime> {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n)\n  }\n}\n\nexport async function getDocumentIndexId(doc: AnyDocument): Promise<string> {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id)\n    }\n\n    return doc.id\n  }\n\n  return await uniqueId()\n}\n\nexport async function validateSchema<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  doc: ResultDocument,\n  schema: T['schema']\n): Promise<string | undefined> {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop]\n\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    if (\n      type === 'geopoint' &&\n      typeof value === 'object' &&\n      typeof value.lon === 'number' &&\n      typeof value.lat === 'number'\n    ) {\n      continue\n    }\n\n    if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n      continue\n    }\n    if (type === 'enum[]' && Array.isArray(value)) {\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n          return prop + '.' + i\n        }\n      }\n      continue\n    }\n\n    if (isVectorType(type)) {\n      const vectorSize = getVectorSize(type)\n      if (!Array.isArray(value) || value.length !== vectorSize) {\n        throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length)\n      }\n      continue\n    }\n\n    if (isArrayType(type)) {\n      if (!Array.isArray(value)) {\n        return prop\n      }\n      const expectedType = getInnerType(type)\n\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i\n        }\n      }\n\n      continue\n    }\n\n    if (typeof type === 'object') {\n      if (!value || typeof value !== 'object') {\n        return prop\n      }\n\n      // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n      const subProp = await validateSchema(value as ResultDocument, type)\n      if (subProp) {\n        return prop + '.' + subProp\n      }\n      continue\n    }\n\n    if (typeof value !== type) {\n      return prop\n    }\n  }\n\n  return undefined\n}\n\nconst IS_ARRAY_TYPE: Record<SearchableType, boolean> = {\n  string: false,\n  number: false,\n  boolean: false,\n  enum: false,\n  geopoint: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n  'enum[]': true\n}\n\nconst INNER_TYPE: Record<ArraySearchableType, ScalarSearchableType> = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n  'enum[]': 'enum'\n}\n\nexport function isGeoPointType(type: unknown): type is Point {\n  return type === 'geopoint'\n}\n\nexport function isVectorType(type: unknown): type is Vector {\n  return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type)\n}\n\nexport function isArrayType(type: unknown): type is ArraySearchableType {\n  return typeof type === 'string' && IS_ARRAY_TYPE[type]\n}\n\nexport function getInnerType(type: ArraySearchableType): ScalarSearchableType {\n  return INNER_TYPE[type]\n}\n\nexport function getVectorSize(type: string): number {\n  const size = Number(type.slice(7, -1))\n\n  switch (true) {\n    case isNaN(size):\n      throw createError('INVALID_VECTOR_VALUE', type)\n    case size <= 0:\n      throw createError('INVALID_VECTOR_SIZE', type)\n    default:\n      return size\n  }\n}\n"],"names":["createError","formatNanoseconds","uniqueId","getDocumentProperties","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","lon","lat","Array","isArray","valueLength","length","i","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","undefined","IS_ARRAY_TYPE","string","number","boolean","enum","geopoint","INNER_TYPE","isGeoPointType","test","size","slice","isNaN"],"mappings":"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"}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/internal-document-id-store.ts"],"sourcesContent":["import { AnyOrama } from '../types.js'\n\nexport type DocumentID = string | number\nexport type InternalDocumentID = number\n\nexport type InternalDocumentIDStore = {\n  idToInternalId: Map<string, number>\n  internalIdToId: string[]\n  save: (store: InternalDocumentIDStore) => unknown\n  load: <T extends AnyOrama>(orama: T, raw: unknown) => void\n}\n\nexport function createInternalDocumentIDStore(): InternalDocumentIDStore {\n  return {\n    idToInternalId: new Map(),\n    internalIdToId: [],\n    save,\n    load\n  }\n}\n\nexport function save(store: InternalDocumentIDStore): unknown {\n  return {\n    internalIdToId: store.internalIdToId\n  }\n}\n\nexport function load<T extends AnyOrama>(orama: T, raw: unknown): void {\n  const { internalIdToId } = raw as InternalDocumentIDStore\n\n  orama.internalDocumentIDStore.idToInternalId.clear()\n  orama.internalDocumentIDStore.internalIdToId = []\n  const internalIdToIdLength = internalIdToId.length\n\n  for (let i = 0; i < internalIdToIdLength; i++) {\n    const internalIdItem = internalIdToId[i]\n    orama.internalDocumentIDStore.idToInternalId.set(internalIdItem, i + 1)\n    orama.internalDocumentIDStore.internalIdToId.push(internalIdItem)\n  }\n}\n\nexport function getInternalDocumentId(store: InternalDocumentIDStore, id: DocumentID): InternalDocumentID {\n  if (typeof id === 'string') {\n    const internalId = store.idToInternalId.get(id)\n\n    if (internalId) {\n      return internalId\n    }\n\n    const currentId = store.idToInternalId.size + 1\n\n    store.idToInternalId.set(id, currentId)\n    store.internalIdToId.push(id)\n\n    return currentId\n  }\n\n  if (id > store.internalIdToId.length) {\n    return getInternalDocumentId(store, id.toString())\n  }\n\n  return id\n}\n\nexport function getDocumentIdFromInternalId(store: InternalDocumentIDStore, internalId: InternalDocumentID): string {\n  if (store.internalIdToId.length < internalId) {\n    throw new Error(`Invalid internalId ${internalId}`)\n  }\n\n  return store.internalIdToId[internalId - 1]\n}\n"],"names":["createInternalDocumentIDStore","idToInternalId","Map","internalIdToId","save","load","store","orama","raw","internalDocumentIDStore","clear","internalIdToIdLength","length","i","internalIdItem","set","push","getInternalDocumentId","id","internalId","get","currentId","size","toString","getDocumentIdFromInternalId","Error"],"mappings":";;;;;;;;;;;;AAYO,SAASA,gCAAyD;IACvE,OAAO;QACLC,gBAAgB,IAAIC;QACpBC,gBAAgB,EAAE;QAClBC;QACAC;IACF;AACF,CAAC;AAEM,SAASD,KAAKE,KAA8B,EAAW;IAC5D,OAAO;QACLH,gBAAgBG,MAAMH,cAAc;IACtC;AACF,CAAC;AAEM,SAASE,KAAyBE,KAAQ,EAAEC,GAAY,EAAQ;IACrE,MAAM,EAAEL,cAAAA,CAAc,CAAE,GAAGK;IAE3BD,MAAME,uBAAuB,CAACR,cAAc,CAACS,KAAK;IAClDH,MAAME,uBAAuB,CAACN,cAAc,GAAG,EAAE;IACjD,MAAMQ,uBAAuBR,eAAeS,MAAM;IAElD,IAAK,IAAIC,IAAI,GAAGA,IAAIF,sBAAsBE,IAAK;QAC7C,MAAMC,iBAAiBX,cAAc,CAACU,EAAE;QACxCN,MAAME,uBAAuB,CAACR,cAAc,CAACc,GAAG,CAACD,gBAAgBD,IAAI;QACrEN,MAAME,uBAAuB,CAACN,cAAc,CAACa,IAAI,CAACF;IACpD;AACF,CAAC;AAEM,SAASG,sBAAsBX,KAA8B,EAAEY,EAAc,EAAsB;IACxG,IAAI,OAAOA,OAAO,UAAU;QAC1B,MAAMC,aAAab,MAAML,cAAc,CAACmB,GAAG,CAACF;QAE5C,IAAIC,YAAY;YACd,OAAOA;QACT,CAAC;QAED,MAAME,YAAYf,MAAML,cAAc,CAACqB,IAAI,GAAG;QAE9ChB,MAAML,cAAc,CAACc,GAAG,CAACG,IAAIG;QAC7Bf,MAAMH,cAAc,CAACa,IAAI,CAACE;QAE1B,OAAOG;IACT,CAAC;IAED,IAAIH,KAAKZ,MAAMH,cAAc,CAACS,MAAM,EAAE;QACpC,OAAOK,sBAAsBX,OAAOY,GAAGK,QAAQ;IACjD,CAAC;IAED,OAAOL;AACT,CAAC;AAEM,SAASM,4BAA4BlB,KAA8B,EAAEa,UAA8B,EAAU;IAClH,IAAIb,MAAMH,cAAc,CAACS,MAAM,GAAGO,YAAY;QAC5C,MAAM,IAAIM,MAAM,CAAC,mBAAmB,EAAEN,WAAW,CAAC,EAAC;IACrD,CAAC;IAED,OAAOb,MAAMH,cAAc,CAACgB,aAAa,EAAE;AAC7C,CAAC"}},
    {"offset": {"line": 657, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/documents-store.ts"],"sourcesContent":["import { AnyDocument, AnyDocumentStore, AnyOrama, IDocumentsStore, TypedDocument } from '../types.js'\nimport {\n  DocumentID,\n  InternalDocumentID,\n  InternalDocumentIDStore,\n  getInternalDocumentId\n} from './internal-document-id-store.js'\n\nexport interface DocumentsStore extends AnyDocumentStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  docs: Record<InternalDocumentID, AnyDocument>\n  count: number\n}\n\nexport async function create<T extends AnyOrama>(\n  _: T,\n  sharedInternalDocumentStore: InternalDocumentIDStore\n): Promise<DocumentsStore> {\n  return {\n    sharedInternalDocumentStore,\n    docs: {},\n    count: 0\n  }\n}\n\nexport async function get<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  store: DocumentsStore,\n  id: DocumentID\n): Promise<ResultDocument | undefined> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  return store.docs[internalId]\n}\n\nexport async function getMultiple<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  store: DocumentsStore,\n  ids: DocumentID[]\n): Promise<(ResultDocument | undefined)[]> {\n  const idsLength = ids.length\n  const found: (ResultDocument | undefined)[] = Array.from({ length: idsLength })\n\n  for (let i = 0; i < idsLength; i++) {\n    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, ids[i])\n    found[i] = store.docs[internalId]\n  }\n\n  return found\n}\n\nexport async function getAll<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  store: DocumentsStore\n): Promise<Record<InternalDocumentID, ResultDocument>> {\n  return store.docs\n}\n\nexport async function store(store: DocumentsStore, id: DocumentID, doc: AnyDocument): Promise<boolean> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  if (typeof store.docs[internalId] !== 'undefined') {\n    return false\n  }\n\n  store.docs[internalId] = doc\n  store.count++\n\n  return true\n}\n\nexport async function remove(store: DocumentsStore, id: DocumentID): Promise<boolean> {\n  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id)\n\n  if (typeof store.docs[internalId] === 'undefined') {\n    return false\n  }\n\n  delete store.docs[internalId]\n  store.count--\n\n  return true\n}\n\nexport async function count(store: DocumentsStore): Promise<number> {\n  return store.count\n}\n\nexport async function load<R = unknown>(\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  raw: R\n): Promise<DocumentsStore> {\n  const rawDocument = raw as DocumentsStore\n\n  return {\n    docs: rawDocument.docs,\n    count: rawDocument.count,\n    sharedInternalDocumentStore\n  }\n}\n\nexport async function save<R = unknown>(store: DocumentsStore): Promise<R> {\n  return {\n    docs: store.docs,\n    count: store.count\n  } as R\n}\n\nexport async function createDocumentsStore(): Promise<IDocumentsStore<DocumentsStore>> {\n  return {\n    create,\n    get,\n    getMultiple,\n    getAll,\n    store,\n    remove,\n    count,\n    load,\n    save\n  }\n}\n"],"names":["getInternalDocumentId","create","_","sharedInternalDocumentStore","docs","count","get","store","id","internalId","getMultiple","ids","idsLength","length","found","Array","from","i","getAll","doc","remove","load","raw","rawDocument","save","createDocumentsStore"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,SAIEA,qBAAqB,QAChB,kCAAiC;;AAQjC,eAAeC,OACpBC,CAAI,EACJC,2BAAoD,EAC3B;IACzB,OAAO;QACLA;QACAC,MAAM,CAAC;QACPC,OAAO;IACT;AACF,CAAC;AAEM,eAAeC,IACpBC,KAAqB,EACrBC,EAAc,EACuB;IACrC,MAAMC,iBAAaT,yNAAAA,EAAsBO,MAAMJ,2BAA2B,EAAEK;IAE5E,OAAOD,MAAMH,IAAI,CAACK,WAAW;AAC/B,CAAC;AAEM,eAAeC,YACpBH,KAAqB,EACrBI,GAAiB,EACwB;IACzC,MAAMC,YAAYD,IAAIE,MAAM;IAC5B,MAAMC,QAAwCC,MAAMC,IAAI,CAAC;QAAEH,QAAQD;IAAU;IAE7E,IAAK,IAAIK,IAAI,GAAGA,IAAIL,WAAWK,IAAK;QAClC,MAAMR,iBAAaT,yNAAAA,EAAsBO,MAAMJ,2BAA2B,EAAEQ,GAAG,CAACM,EAAE;QAClFH,KAAK,CAACG,EAAE,GAAGV,MAAMH,IAAI,CAACK,WAAW;IACnC;IAEA,OAAOK;AACT,CAAC;AAEM,eAAeI,OACpBX,KAAqB,EACgC;IACrD,OAAOA,MAAMH,IAAI;AACnB,CAAC;AAEM,eAAeG,MAAMA,KAAqB,EAAEC,EAAc,EAAEW,GAAgB,EAAoB;IACrG,MAAMV,iBAAaT,yNAAAA,EAAsBO,MAAMJ,2BAA2B,EAAEK;IAE5E,IAAI,OAAOD,MAAMH,IAAI,CAACK,WAAW,KAAK,aAAa;QACjD,OAAO,KAAK;IACd,CAAC;IAEDF,MAAMH,IAAI,CAACK,WAAW,GAAGU;IACzBZ,MAAMF,KAAK;IAEX,OAAO,IAAI;AACb,CAAC;AAEM,eAAee,OAAOb,KAAqB,EAAEC,EAAc,EAAoB;IACpF,MAAMC,iBAAaT,yNAAAA,EAAsBO,MAAMJ,2BAA2B,EAAEK;IAE5E,IAAI,OAAOD,MAAMH,IAAI,CAACK,WAAW,KAAK,aAAa;QACjD,OAAO,KAAK;IACd,CAAC;IAED,OAAOF,MAAMH,IAAI,CAACK,WAAW;IAC7BF,MAAMF,KAAK;IAEX,OAAO,IAAI;AACb,CAAC;AAEM,eAAeA,MAAME,KAAqB,EAAmB;IAClE,OAAOA,MAAMF,KAAK;AACpB,CAAC;AAEM,eAAegB,KACpBlB,2BAAoD,EACpDmB,GAAM,EACmB;IACzB,MAAMC,cAAcD;IAEpB,OAAO;QACLlB,MAAMmB,YAAYnB,IAAI;QACtBC,OAAOkB,YAAYlB,KAAK;QACxBF;IACF;AACF,CAAC;AAEM,eAAeqB,KAAkBjB,KAAqB,EAAc;IACzE,OAAO;QACLH,MAAMG,MAAMH,IAAI;QAChBC,OAAOE,MAAMF,KAAK;IACpB;AACF,CAAC;AAEM,eAAeoB,uBAAiE;IACrF,OAAO;QACLxB;QACAK;QACAI;QACAQ;QACAX;QACAa;QACAf;QACAgB;QACAG;IACF;AACF,CAAC"}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/plugins.ts"],"sourcesContent":["import type { AnyOrama, OramaPlugin } from '../types.js'\nimport { createError } from '../errors.js'\n\nexport type AvailablePluginHooks = (typeof AVAILABLE_PLUGIN_HOOKS)[number]\n\nexport const AVAILABLE_PLUGIN_HOOKS = [\n  'beforeInsert',\n  'afterInsert',\n  'beforeRemove',\n  'afterRemove',\n  'beforeUpdate',\n  'afterUpdate',\n  'beforeSearch',\n  'afterSearch',\n  'beforeInsertMultiple',\n  'afterInsertMultiple',\n  'beforeRemoveMultiple',\n  'afterRemoveMultiple',\n  'beforeUpdateMultiple',\n  'afterUpdateMultiple',\n  'beforeLoad',\n  'afterLoad',\n  'afterCreate'\n] as const\n\nexport async function getAllPluginsByHook<T extends AnyOrama>(\n  orama: T,\n  hook: AvailablePluginHooks\n): Promise<OramaPlugin[]> {\n  const pluginsToRun: OramaPlugin[] = []\n  const pluginsLength = orama.plugins?.length\n\n  if (!pluginsLength) {\n    return pluginsToRun\n  }\n\n  for (let i = 0; i < pluginsLength; i++) {\n    try {\n      const plugin = await orama.plugins[i]\n      if (typeof plugin[hook] === 'function') {\n        pluginsToRun.push(plugin[hook] as OramaPlugin)\n      }\n    } catch (error) {\n      console.error('Caught error in getAllPluginsByHook:', error)\n      throw createError('PLUGIN_CRASHED')\n    }\n  }\n\n  return pluginsToRun\n}\n"],"names":["createError","AVAILABLE_PLUGIN_HOOKS","getAllPluginsByHook","orama","hook","pluginsToRun","pluginsLength","plugins","length","i","plugin","push","error","console"],"mappings":";;;;;;AACA,SAASA,WAAW,QAAQ,eAAc;;AAInC,MAAMC,yBAAyB;IACpC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD,CAAS;AAEH,eAAeC,oBACpBC,KAAQ,EACRC,IAA0B,EACF;QAEFD;IADtB,MAAME,eAA8B,EAAE;IACtC,MAAMC,gBAAgBH,CAAAA,iBAAAA,MAAMI,OAAO,MAAA,QAAbJ,mBAAAA,KAAAA,IAAAA,KAAAA,IAAAA,eAAeK,MAAM;IAE3C,IAAI,CAACF,eAAe;QAClB,OAAOD;IACT,CAAC;IAED,IAAK,IAAII,IAAI,GAAGA,IAAIH,eAAeG,IAAK;QACtC,IAAI;YACF,MAAMC,SAAS,MAAMP,MAAMI,OAAO,CAACE,EAAE;YACrC,IAAI,OAAOC,MAAM,CAACN,KAAK,KAAK,YAAY;gBACtCC,aAAaM,IAAI,CAACD,MAAM,CAACN,KAAK;YAChC,CAAC;QACH,EAAE,OAAOQ,OAAO;YACdC,QAAQD,KAAK,CAAC,wCAAwCA;YACtD,UAAMZ,oKAAAA,EAAY,kBAAiB;QACrC;IACF;IAEA,OAAOK;AACT,CAAC"}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/hooks.ts"],"sourcesContent":["import {\n  BeforeSearch,\n  AfterSearch,\n  AnyOrama,\n  MultipleCallbackComponent,\n  Results,\n  SearchParams,\n  SingleCallbackComponent,\n  TypedDocument,\n  AfterCreate\n} from '../types.js'\n\nexport const OBJECT_COMPONENTS = ['tokenizer', 'index', 'documentsStore', 'sorter']\n\nexport const FUNCTION_COMPONENTS = [\n  'validateSchema',\n  'getDocumentIndexId',\n  'getDocumentProperties',\n  'formatElapsedTime'\n]\n\nexport const SINGLE_OR_ARRAY_COMPONENTS = [\n  /* deprecated with v2.0.0-beta.5 */\n]\n\nexport async function runSingleHook<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  hooks: SingleCallbackComponent<T>[],\n  orama: T,\n  id: string,\n  doc?: ResultDocument\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](orama, id, doc)\n  }\n}\n\nexport async function runMultipleHook<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  hooks: MultipleCallbackComponent<T>[],\n  orama: T,\n  docsOrIds: ResultDocument[] | string[]\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](orama, docsOrIds)\n  }\n}\n\nexport async function runAfterSearch<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  hooks: AfterSearch<T, ResultDocument>[],\n  db: T,\n  params: SearchParams<T, ResultDocument>,\n  language: string | undefined,\n  results: Results<ResultDocument>\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](db, params, language, results)\n  }\n}\n\nexport async function runBeforeSearch<T extends AnyOrama>(\n  hooks: BeforeSearch<T>[],\n  db: T,\n  params: SearchParams<T, TypedDocument<any>>,\n  language: string | undefined\n): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](db, params, language)\n  }\n}\n\nexport async function runAfterCreate<T extends AnyOrama>(hooks: AfterCreate<T>[], db: T): Promise<void> {\n  const hooksLength = hooks.length\n  for (let i = 0; i < hooksLength; i++) {\n    await hooks[i](db)\n  }\n}\n"],"names":["OBJECT_COMPONENTS","FUNCTION_COMPONENTS","SINGLE_OR_ARRAY_COMPONENTS","runSingleHook","hooks","orama","id","doc","hooksLength","length","i","runMultipleHook","docsOrIds","runAfterSearch","db","params","language","results","runBeforeSearch","runAfterCreate"],"mappings":";;;;;;;;;;;;;;;;;;AAYO,MAAMA,oBAAoB;IAAC;IAAa;IAAS;IAAkB;CAAS,CAAA;AAE5E,MAAMC,sBAAsB;IACjC;IACA;IACA;IACA;CACD,CAAA;AAEM,MAAMC,6BAA6B,EAEzC,CAAA;AAEM,eAAeC,cACpBC,KAAmC,EACnCC,KAAQ,EACRC,EAAU,EACVC,GAAoB,EACL;IACf,MAAMC,cAAcJ,MAAMK,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,aAAaE,IAAK;QACpC,MAAMN,KAAK,CAACM,EAAE,CAACL,OAAOC,IAAIC;IAC5B;AACF,CAAC;AAEM,eAAeI,gBACpBP,KAAqC,EACrCC,KAAQ,EACRO,SAAsC,EACvB;IACf,MAAMJ,cAAcJ,MAAMK,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,aAAaE,IAAK;QACpC,MAAMN,KAAK,CAACM,EAAE,CAACL,OAAOO;IACxB;AACF,CAAC;AAEM,eAAeC,eACpBT,KAAuC,EACvCU,EAAK,EACLC,MAAuC,EACvCC,QAA4B,EAC5BC,OAAgC,EACjB;IACf,MAAMT,cAAcJ,MAAMK,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,aAAaE,IAAK;QACpC,MAAMN,KAAK,CAACM,EAAE,CAACI,IAAIC,QAAQC,UAAUC;IACvC;AACF,CAAC;AAEM,eAAeC,gBACpBd,KAAwB,EACxBU,EAAK,EACLC,MAA2C,EAC3CC,QAA4B,EACb;IACf,MAAMR,cAAcJ,MAAMK,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,aAAaE,IAAK;QACpC,MAAMN,KAAK,CAACM,EAAE,CAACI,IAAIC,QAAQC;IAC7B;AACF,CAAC;AAEM,eAAeG,eAAmCf,KAAuB,EAAEU,EAAK,EAAiB;IACtG,MAAMN,cAAcJ,MAAMK,MAAM;IAChC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,aAAaE,IAAK;QACpC,MAAMN,KAAK,CAACM,EAAE,CAACI;IACjB;AACF,CAAC"}},
    {"offset": {"line": 874, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/trees/avl.ts"],"sourcesContent":["import { Nullable } from '../types.js'\nimport { safeArrayPush } from '../utils.js'\n\nexport interface Node<K, V> {\n  // Node key\n  k: K\n  // Node value\n  v: V\n  // Left child node\n  l: Nullable<Node<K, V>>\n  // Right child node\n  r: Nullable<Node<K, V>>\n  // Tree height from this node\n  h: number\n}\n\nexport interface RootNode<K, V> {\n  root: Node<K, V>\n}\n\nfunction rotateLeft<K, V>(node: Node<K, V>): Node<K, V> {\n  const right = node.r as Node<K, V>\n  node.r = right.l\n  right.l = node\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1\n  right.h = Math.max(getHeight(right.l), getHeight(right.r)) + 1\n  return right\n}\n\nfunction rotateRight<K, V>(node: Node<K, V>): Node<K, V> {\n  const left = node.l as Node<K, V>\n  node.l = left.r\n  left.r = node\n  node.h = Math.max(getHeight(node.l), getHeight(node.r)) + 1\n  left.h = Math.max(getHeight(left.l), getHeight(left.r)) + 1\n  return left\n}\n\nexport function contains<K, V>(node: RootNode<K, V>, key: K): boolean {\n  return !!find(node, key)\n}\n\nexport function getSize<K, V>(root: Nullable<RootNode<K, V>>): number {\n  let size = 0\n  const queue: Array<Node<K, V>> = []\n\n  if (root !== null) {\n    queue.push(root.root)\n  }\n\n  while (queue.length > 0) {\n    const node = queue.shift() as Node<K, V>\n    size++\n\n    if (node.l !== null) {\n      queue.push(node.l)\n    }\n\n    if (node.r !== null) {\n      queue.push(node.r)\n    }\n  }\n\n  return size\n}\n\nexport function isBalanced<K, V>(root: Nullable<RootNode<K, V>>): boolean {\n  if (root === null) return true\n\n  const stack: Array<Node<K, V>> = [root.root]\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n\n    if (node != null) {\n      const leftHeight = getHeight(node.l)\n      const rightHeight = getHeight(node.r)\n      const heightDiff = leftHeight - rightHeight\n\n      if (Math.abs(heightDiff) > 1) {\n        return false\n      }\n\n      if (node.l !== null) {\n        stack.push(node.l)\n      }\n      if (node.r !== null) {\n        stack.push(node.r)\n      }\n    }\n  }\n\n  return true\n}\n\nexport function rangeSearch<K, V>(node: RootNode<K, V>, min: K, max: K): V {\n  const result: V[] = []\n\n  function traverse(node: Node<K, V>) {\n    if (node === null) {\n      return\n    }\n\n    if (min < node.k) {\n      traverse(node.l as Node<K, V>)\n    }\n\n    if (node.k >= min && node.k <= max) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    if (max > node.k) {\n      traverse(node.r as Node<K, V>)\n    }\n  }\n\n  traverse(node.root)\n\n  return result as V\n}\n\nexport function greaterThan<K, V>(node: RootNode<K, V>, key: K, inclusive = false): V {\n  const result: V[] = []\n\n  if (node === null) return result as V\n\n  const stack: Array<Nullable<Node<K, V>>> = [node.root]\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n    if (!node) {\n      continue\n    }\n\n    if (inclusive && node.k >= key) {\n      safeArrayPush(result, node.v as V[])\n    }\n    if (!inclusive && node.k > key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    stack.push(node.r)\n    stack.push(node.l)\n  }\n\n  return result as V\n}\n\nexport function lessThan<K, V>(node: RootNode<K, V>, key: K, inclusive = false): V {\n  const result: V[] = []\n\n  if (node === null) return result as V\n\n  const stack: Array<Nullable<Node<K, V>>> = [node.root]\n\n  while (stack.length > 0) {\n    const node = stack.pop()\n    if (!node) {\n      continue\n    }\n\n    if (inclusive && node.k <= key) {\n      safeArrayPush(result, node.v as V[])\n    }\n    if (!inclusive && node.k < key) {\n      safeArrayPush(result, node.v as V[])\n    }\n\n    stack.push(node.r)\n    stack.push(node.l)\n  }\n\n  return result as V\n}\n\nfunction getNodeByKey<K, V>(node: Nullable<Node<K, V>>, key: K): Nullable<Node<K, V>> {\n  while (node !== null) {\n    if (key < node.k) {\n      node = node.l\n    } else if (key > node.k) {\n      node = node.r\n    } else {\n      return node\n    }\n  }\n  return null\n}\n\nexport function create<K, V>(key: K, value: V): RootNode<K, V> {\n  return {\n    root: {\n      k: key,\n      v: value,\n      l: null,\n      r: null,\n      h: 0\n    }\n  }\n}\n\nlet insertCount = 0\n\nexport function insert<K, V>(rootNode: RootNode<K, V[]>, key: K, newValue: V[], rebalanceThreshold = 500): void {\n  function insertNode(node: Nullable<Node<K, V[]>>, key: K, newValue: V[]): Node<K, V[]> {\n    if (node === null) {\n      insertCount++\n      return {\n        k: key,\n        v: newValue,\n        l: null,\n        r: null,\n        h: 0\n      }\n    }\n\n    if (key < node.k) {\n      node.l = insertNode(node.l, key, newValue)\n    } else if (key > node.k) {\n      node.r = insertNode(node.r, key, newValue)\n    } else {\n      node.v.push(...newValue)\n      return node\n    }\n\n    // Rebalance the tree if the insert count reaches the threshold.\n    // This will improve insertion performance since we won't be rebalancing the tree on every insert.\n    // When inserting docs using `insertMultiple`, the threshold will be set to the number of docs being inserted.\n    // We can force rebalancing the tree by setting the threshold to 1 (default).\n    if (insertCount % rebalanceThreshold === 0) {\n      return rebalanceNode(node, key)\n    }\n\n    return node\n  }\n\n  rootNode.root = insertNode(rootNode.root, key, newValue)\n}\n\nfunction rebalanceNode<K, V>(node: Node<K, V[]>, key: K): Node<K, V[]> {\n  node.h = 1 + Math.max(getHeight(node.l), getHeight(node.r))\n\n  const balanceFactor = getHeight(node.l) - getHeight(node.r)\n\n  if (balanceFactor > 1 && key < node.l!.k) {\n    return rotateRight(node)\n  }\n\n  if (balanceFactor < -1 && key > node.r!.k) {\n    return rotateLeft(node)\n  }\n\n  if (balanceFactor > 1 && key > node.l!.k) {\n    node.l = rotateLeft(node.l!)\n    return rotateRight(node)\n  }\n\n  if (balanceFactor < -1 && key < node.r!.k) {\n    node.r = rotateRight(node.r!)\n    return rotateLeft(node)\n  }\n\n  return node\n}\n\nfunction getHeight<K, V>(node: Nullable<Node<K, V>>): number {\n  return node !== null ? node.h : -1\n}\n\nexport function find<K, V>(root: RootNode<K, V>, key: K): Nullable<V> {\n  const node = getNodeByKey(root.root, key)\n  if (node === null) {\n    return null\n  }\n  return node.v\n}\n\nexport function remove<K, V>(rootNode: Nullable<RootNode<K, V>>, key: K): void {\n  if (rootNode === null || rootNode.root === null) {\n    return\n  }\n\n  let node = rootNode.root\n  let parentNode: Nullable<Node<K, V>> = null\n\n  while (node != null && node.k !== key) {\n    parentNode = node\n    if (key < node.k) {\n      node = node.l!\n    } else {\n      node = node.r!\n    }\n  }\n\n  if (node === null) {\n    return\n  }\n\n  const deleteNode = () => {\n    if (node.l === null && node.r === null) {\n      if (parentNode === null) {\n        rootNode.root = null!\n      } else {\n        if (parentNode.l === node) {\n          parentNode.l = null\n        } else {\n          parentNode.r = null\n        }\n      }\n    } else if (node.l != null && node.r != null) {\n      let minValueNode = node.r\n      let minValueParent = node\n\n      while (minValueNode.l != null) {\n        minValueParent = minValueNode\n        minValueNode = minValueNode.l\n      }\n\n      node.k = minValueNode.k\n\n      if (minValueParent === node) {\n        minValueParent.r = minValueNode.r\n      } else {\n        minValueParent.l = minValueNode.r\n      }\n    } else {\n      const childNode = node.l != null ? node.l : node.r\n\n      if (parentNode === null) {\n        rootNode.root = childNode!\n      } else {\n        if (parentNode.l === node) {\n          parentNode.l = childNode\n        } else {\n          parentNode.r = childNode\n        }\n      }\n    }\n  }\n\n  deleteNode()\n}\n\nexport function removeDocument<K, V>(root: RootNode<K, V[]>, id: V, key: K): void {\n  const node = getNodeByKey(root.root, key)!\n\n  if (!node) {\n    return\n  }\n\n  if (node.v.length === 1) {\n    remove(root, key)\n    return\n  }\n\n  node.v.splice(node.v.indexOf(id), 1)\n}\n"],"names":["safeArrayPush","rotateLeft","node","right","r","l","h","Math","max","getHeight","rotateRight","left","contains","key","find","getSize","root","size","queue","push","length","shift","isBalanced","stack","pop","leftHeight","rightHeight","heightDiff","abs","rangeSearch","min","result","traverse","k","v","greaterThan","inclusive","lessThan","getNodeByKey","create","value","insertCount","insert","rootNode","newValue","rebalanceThreshold","insertNode","rebalanceNode","balanceFactor","remove","parentNode","deleteNode","minValueNode","minValueParent","childNode","removeDocument","id","splice","indexOf"],"mappings":"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"}},
    {"offset": {"line": 1179, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/trees/flat.ts"],"sourcesContent":["import type { Point } from './bkd.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { EnumArrComparisonOperator, EnumComparisonOperator, Nullable, ScalarSearchableValue } from '../types.js'\nimport { intersect, safeArrayPush } from '../utils.js'\n\nexport interface FlatTree {\n  numberToDocumentId: Map<ScalarSearchableValue, InternalDocumentID[]>\n}\n\nexport function create(): FlatTree {\n  return {\n    numberToDocumentId: new Map()\n  }\n}\n\nexport function insert(root: FlatTree, key: ScalarSearchableValue, value: InternalDocumentID): FlatTree {\n  if (root.numberToDocumentId.has(key)) {\n    root.numberToDocumentId.get(key)!.push(value)\n    return root\n  }\n  root.numberToDocumentId.set(key, [value])\n  return root\n}\n\nexport function find(root: FlatTree, key: ScalarSearchableValue): Nullable<InternalDocumentID[]> {\n  return root.numberToDocumentId.get(key) ?? null\n}\n\nexport function remove(root: Nullable<FlatTree>, key: ScalarSearchableValue): Nullable<FlatTree> {\n  if (root != null) {\n    root.numberToDocumentId.delete(key)\n  }\n  return root\n}\nexport function removeDocument(root: FlatTree, id: InternalDocumentID, key: ScalarSearchableValue): void {\n  root?.numberToDocumentId.set(key, root?.numberToDocumentId.get(key)?.filter((v) => v !== id) ?? [])\n  if (root?.numberToDocumentId.get(key)?.length === 0) {\n    root?.numberToDocumentId.delete(key)\n  }\n}\n\nexport function contains(node: FlatTree, key: ScalarSearchableValue): boolean {\n  return !(find(node, key) == null)\n}\n\nexport function getSize(root: Nullable<FlatTree>): number {\n  let size = 0\n  for (const [, value] of root?.numberToDocumentId ?? []) {\n    size += value.length\n  }\n  return size\n}\nexport function filter(root: FlatTree, operation: EnumComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumComparisonOperator\n  switch (operationType) {\n    case 'eq': {\n      const value = operation[operationType]!\n      return root.numberToDocumentId.get(value) ?? []\n    }\n    case 'in': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n      for (const v of value) {\n        const ids = root.numberToDocumentId.get(v)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n    case 'nin': {\n      const value = operation[operationType]!\n      const result: InternalDocumentID[] = []\n\n      const keys = root.numberToDocumentId.keys()\n      for (const key of keys) {\n        if (value.includes(key as Exclude<ScalarSearchableValue, Point>)) {\n          continue\n        }\n        const ids = root.numberToDocumentId.get(key)\n        if (ids != null) {\n          safeArrayPush(result, ids)\n        }\n      }\n      return result\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n\nexport function filterArr(root: FlatTree, operation: EnumArrComparisonOperator): InternalDocumentID[] {\n  const operationKeys = Object.keys(operation)\n\n  if (operationKeys.length !== 1) {\n    throw new Error('Invalid operation')\n  }\n\n  const operationType = operationKeys[0] as keyof EnumArrComparisonOperator\n  switch (operationType) {\n    case 'containsAll': {\n      const values = operation[operationType]!\n      const ids = values.map((value) => root.numberToDocumentId.get(value) ?? [])\n      return intersect(ids)\n    }\n  }\n\n  throw new Error('Invalid operation')\n}\n"],"names":["intersect","safeArrayPush","create","numberToDocumentId","Map","insert","root","key","value","has","get","push","set","find","remove","delete","removeDocument","id","filter","v","length","contains","node","getSize","size","operation","operationKeys","Object","keys","Error","operationType","result","ids","includes","filterArr","values","map"],"mappings":"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"}},
    {"offset": {"line": 1305, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/levenshtein.ts"],"sourcesContent":["export type BoundedMetric = {\n  isBounded: boolean\n  distance: number\n}\n\n/**\n * Inspired by:\n * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340\n */\nfunction _boundedLevenshtein(a: string, b: string, tolerance: number): number {\n  // Handle base cases\n  if (tolerance < 0) return -1\n  if (a === b) return 0\n\n  const m = a.length\n  const n = b.length\n\n  // Special case for empty strings\n  if (m === 0) return n <= tolerance ? n : -1\n  if (n === 0) return m <= tolerance ? m : -1\n\n  a = a.toLowerCase()\n  b = b.toLowerCase()\n\n  // Special case for prefixes\n  if (b.startsWith(a) || a.startsWith(b)) return 0\n\n  // If the length difference is greater than the tolerance, return early\n  if (Math.abs(m - n) > tolerance) return -1\n\n  // Initialize the matrix\n  const matrix: number[][] = []\n  for (let i = 0; i <= m; i++) {\n    matrix[i] = [i]\n    for (let j = 1; j <= n; j++) {\n      matrix[i][j] = i === 0 ? j : 0\n    }\n  }\n\n  // Fill the matrix\n  for (let i = 1; i <= m; i++) {\n    let rowMin = Infinity\n    for (let j = 1; j <= n; j++) {\n      if (a[i - 1] === b[j - 1]) {\n        matrix[i][j] = matrix[i - 1][j - 1]\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j] + 1, // deletion\n          matrix[i][j - 1] + 1, // insertion\n          matrix[i - 1][j - 1] + 1 // substitution\n        )\n      }\n      rowMin = Math.min(rowMin, matrix[i][j])\n    }\n\n    // Early termination if all values in this row exceed tolerance\n    if (rowMin > tolerance) {\n      return -1\n    }\n  }\n\n  return matrix[m][n] <= tolerance ? matrix[m][n] : -1\n}\n\n/**\n * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance\n * is greater than the given tolerance.\n * It assumes that:\n * - tolerance >= ||a| - |b|| >= 0\n */\nexport async function boundedLevenshtein(a: string, b: string, tolerance: number): Promise<BoundedMetric> {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0\n  }\n}\n\n// This is only used internally, keep in sync with the previous one\nexport function syncBoundedLevenshtein(a: string, b: string, tolerance: number): BoundedMetric {\n  const distance = _boundedLevenshtein(a, b, tolerance)\n  return {\n    distance,\n    isBounded: distance >= 0\n  }\n}\n\nexport function levenshtein(a: string, b: string): number {\n  /* c8 ignore next 3 */\n  if (!a.length) {\n    return b.length\n  }\n\n  /* c8 ignore next 3 */\n  if (!b.length) {\n    return a.length\n  }\n\n  const swap = a\n  if (a.length > b.length) {\n    a = b\n    b = swap\n  }\n\n  const row = Array.from({ length: a.length + 1 }, (_, i) => i)\n  let val = 0\n\n  for (let i = 1; i <= b.length; i++) {\n    let prev = i\n\n    for (let j = 1; j <= a.length; j++) {\n      if (b[i - 1] === a[j - 1]) {\n        val = row[j - 1]\n      } else {\n        val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1))\n      }\n\n      row[j - 1] = prev\n      prev = val\n    }\n    row[a.length] = prev\n  }\n\n  return row[a.length]\n}\n"],"names":["_boundedLevenshtein","a","b","tolerance","m","length","n","toLowerCase","startsWith","Math","abs","matrix","i","j","rowMin","Infinity","min","boundedLevenshtein","distance","isBounded","syncBoundedLevenshtein","levenshtein","swap","row","Array","from","_","val","prev"],"mappings":"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"}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/trees/radix.ts"],"sourcesContent":["import { syncBoundedLevenshtein } from '../components/levenshtein.js'\nimport { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getOwnProperty } from '../utils.js'\n\nexport class Node {\n  constructor(key: string, subWord: string, end: boolean) {\n    this.k = key\n    this.s = subWord\n    this.e = end\n  }\n\n  // Node key\n  public k: string\n  // Node subword\n  public s: string\n  // Node children\n  public c: Record<string, Node> = {}\n  // Node documents\n  public d: InternalDocumentID[] = []\n  // Node end\n  public e: boolean\n  // Node word\n  public w = ''\n\n  public toJSON(): object {\n    return {\n      w: this.w,\n      s: this.s,\n      c: this.c,\n      d: this.d,\n      e: this.e\n    }\n  }\n}\n\ninterface FindParams {\n  term: string\n  exact?: boolean\n  tolerance?: number\n}\n\ntype FindResult = Record<string, InternalDocumentID[]>\n\nfunction updateParent(node: Node, parent: Node): void {\n  node.w = parent.w + node.s\n}\n\nfunction addDocument(node: Node, docID: InternalDocumentID): void {\n  node.d.push(docID)\n}\n\nfunction removeDocument(node: Node, docID: InternalDocumentID): boolean {\n  const index = node.d.indexOf(docID)\n\n  /* c8 ignore next 3 */\n  if (index === -1) {\n    return false\n  }\n\n  node.d.splice(index, 1)\n\n  return true\n}\n\nfunction findAllWords(node: Node, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.e) {\n    const { w, d: docIDs } = node\n\n    if (exact && w !== term) {\n      return {}\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/askorama/orama/issues/137\n    if (getOwnProperty(output, w) == null) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - w.length)\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {\n          output[w] = []\n        }\n      } else {\n        // prevent default tolerance not set\n        output[w] = []\n      }\n    }\n\n    // check if _output[w] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/askorama/orama/issues/137\n    if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n      const docs = new Set(output[w])\n\n      const docIDsLength = docIDs.length\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i])\n      }\n      output[w] = Array.from(docs)\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.c)) {\n    findAllWords(node.c[character], output, term, exact, tolerance)\n  }\n  return output\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = ''\n  const len = Math.min(a.length, b.length)\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix\n    }\n    commonPrefix += a[i]\n  }\n  return commonPrefix\n}\n\nexport function create(end = false, subWord = '', key = ''): Node {\n  return new Node(key, subWord, end)\n}\n\nexport function insert(root: Node, word: string, docId: InternalDocumentID) {\n  const wordLength = word.length\n  for (let i = 0; i < wordLength; i++) {\n    const currentCharacter = word[i]\n    const wordAtIndex = word.substring(i)\n    const rootChildCurrentChar = root.c[currentCharacter]\n\n    if (rootChildCurrentChar) {\n      const edgeLabel = rootChildCurrentChar.s\n      const edgeLabelLength = edgeLabel.length\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex)\n      const commonPrefixLength = commonPrefix.length\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId)\n        rootChildCurrentChar.e = true\n        return\n      }\n\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength]\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = create(true, wordAtIndex, currentCharacter) // Create a new node with end set to true\n        newNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n\n        const newNodeChild = newNode.c[edgeLabelAtCommonPrefix]\n        newNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        newNodeChild.k = edgeLabelAtCommonPrefix\n\n        root.c[currentCharacter] = newNode\n\n        updateParent(newNode, root)\n        updateParent(newNodeChild, newNode)\n        addDocument(newNode, docId)\n        return\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = create(false, commonPrefix, currentCharacter)\n        inbetweenNode.c[edgeLabelAtCommonPrefix] = rootChildCurrentChar\n        root.c[currentCharacter] = inbetweenNode\n\n        const inbetweenNodeChild = inbetweenNode.c[edgeLabelAtCommonPrefix]\n        inbetweenNodeChild.s = edgeLabel.substring(commonPrefixLength)\n        inbetweenNodeChild.k = edgeLabelAtCommonPrefix\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength]\n        const newNode = create(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix)\n        addDocument(newNode, docId)\n\n        inbetweenNode.c[wordAtCommonPrefix] = newNode\n\n        updateParent(inbetweenNode, root)\n        updateParent(newNode, inbetweenNode)\n        updateParent(inbetweenNodeChild, inbetweenNode)\n        return\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1\n      // navigate in the child node\n      root = rootChildCurrentChar\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = create(true, wordAtIndex, currentCharacter)\n      addDocument(newNode, docId)\n\n      root.c[currentCharacter] = newNode\n      updateParent(newNode, root)\n      return\n    }\n  }\n}\n\nfunction _findLevenshtein(\n  node: Node,\n  term: string,\n  index: number,\n  tolerance: number,\n  originalTolerance: number,\n  output: FindResult\n) {\n  if (tolerance < 0) {\n    return\n  }\n\n  if (node.w.startsWith(term)) {\n    findAllWords(node, output, term, false, 0)\n    return\n  }\n\n  if (node.e) {\n    const { w, d: docIDs } = node\n    if (w) {\n      if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {\n        output[w] = []\n      }\n      if (getOwnProperty(output, w) != null && docIDs.length > 0) {\n        const docs = new Set(output[w])\n\n        const docIDsLength = docIDs.length\n        for (let i = 0; i < docIDsLength; i++) {\n          docs.add(docIDs[i])\n        }\n        output[w] = Array.from(docs)\n      }\n    }\n  }\n\n  if (index >= term.length) {\n    return\n  }\n\n  // Match current character without consuming tolerance\n  if (term[index] in node.c) {\n    _findLevenshtein(node.c[term[index]], term, index + 1, tolerance, originalTolerance, output)\n  }\n\n  // If tolerance is still available, consider other branches:\n  // 1. Deletion (skip the current term character)\n  _findLevenshtein(node, term, index + 1, tolerance - 1, originalTolerance, output)\n\n  // 2. Insertion (skip the current tree node character)\n  for (const character in node.c) {\n    _findLevenshtein(node.c[character], term, index, tolerance - 1, originalTolerance, output)\n  }\n\n  // 3. Substitution (skip both current term character and tree node character)\n  for (const character in node.c) {\n    if (character !== term[index]) {\n      _findLevenshtein(node.c[character], term, index + 1, tolerance - 1, originalTolerance, output)\n    }\n  }\n}\n\nexport function find(root: Node, { term, exact, tolerance }: FindParams): FindResult {\n  // Find the closest node to the term\n\n  // Use `if` condition because tolerance `0` is supposed to match only prefix.\n  // (allows infinite insertions at end, which is against normal levenshtein logic).\n  // (new _findLevenshtein only handles not exact and tolerance>0 condition)\n  if (tolerance && !exact) {\n    const output: FindResult = {}\n    tolerance = tolerance || 0\n\n    _findLevenshtein(root, term, 0, tolerance || 0, tolerance, output)\n    return output\n  } else {\n    const termLength = term.length\n    for (let i = 0; i < termLength; i++) {\n      const character = term[i]\n      if (character in root.c) {\n        const rootChildCurrentChar = root.c[character]\n        const edgeLabel = rootChildCurrentChar.s\n        const termSubstring = term.substring(i)\n\n        // find the common prefix between two words ex: prime and primate = prim\n        const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n        const commonPrefixLength = commonPrefix.length\n        // if the common prefix length is equal to edgeLabel length (the node subword) it means they are a match\n        // if the common prefix is equal to the term means it is contained in the node\n        if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n          // if tolerance is set we take the current node as the closest\n          if (tolerance) break\n          return {}\n        }\n\n        // skip the subword length and check the next divergent character\n        i += rootChildCurrentChar.s.length - 1\n        // navigate into the child node\n        root = rootChildCurrentChar\n      } else {\n        return {}\n      }\n    }\n\n    const output: FindResult = {}\n    // found the closest node we recursively search through children\n    findAllWords(root, output, term, exact, tolerance)\n\n    return output\n  }\n}\n\nexport function contains(root: Node, term: string): boolean {\n  const termLength = term.length\n  for (let i = 0; i < termLength; i++) {\n    const character = term[i]\n\n    if (character in root.c) {\n      const rootChildrenChar = root.c[character]\n      const edgeLabel = rootChildrenChar.s\n      const termSubstring = term.substring(i)\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring)\n      const commonPrefixLength = commonPrefix.length\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false\n      }\n      i += rootChildrenChar.s.length - 1\n      root = rootChildrenChar\n    } else {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeWord(root: Node, term: string): boolean {\n  if (!term) {\n    return false\n  }\n\n  const termLength = term.length\n  for (let i = 0; i < termLength; i++) {\n    const character = term[i]\n    const parent = root\n    if (character in root.c) {\n      i += root.c[character].s.length - 1\n      root = root.c[character]\n\n      if (Object.keys(root.c).length === 0) {\n        delete parent.c[root.k]\n        return true\n      }\n    } else {\n      return false\n    }\n  }\n\n  return false\n}\n\nexport function removeDocumentByWord(root: Node, term: string, docID: InternalDocumentID, exact = true): boolean {\n  if (!term) {\n    return true\n  }\n\n  const termLength = term.length\n  for (let i = 0; i < termLength; i++) {\n    const character = term[i]\n    if (character in root.c) {\n      const rootChildCurrentChar = root.c[character]\n      i += rootChildCurrentChar.s.length - 1\n      root = rootChildCurrentChar\n\n      if (exact && root.w !== term) {\n        // Do nothing if the exact condition is not met.\n      } else {\n        removeDocument(root, docID)\n      }\n    } else {\n      return false\n    }\n  }\n  return true\n}\n"],"names":["syncBoundedLevenshtein","getOwnProperty","Node","constructor","key","subWord","end","k","s","e","c","d","w","toJSON","updateParent","node","parent","addDocument","docID","push","removeDocument","index","indexOf","splice","findAllWords","output","term","exact","tolerance","docIDs","difference","Math","abs","length","isBounded","docs","Set","docIDsLength","i","add","Array","from","character","Object","keys","getCommonPrefix","a","b","commonPrefix","len","min","create","insert","root","word","docId","wordLength","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","edgeLabel","edgeLabelLength","commonPrefixLength","edgeLabelAtCommonPrefix","newNode","newNodeChild","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","_findLevenshtein","originalTolerance","startsWith","find","termLength","termSubstring","contains","rootChildrenChar","removeWord","removeDocumentByWord"],"mappings":"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"}},
    {"offset": {"line": 1737, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/trees/bkd.ts"],"sourcesContent":["import type { Nullable, GenericSorting } from '../types.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\n\nexport interface Point {\n  lon: number\n  lat: number\n}\n\nexport interface Node {\n  point: Point\n  docIDs?: InternalDocumentID[]\n  left?: Node\n  right?: Node\n  parent?: Node\n}\n\nexport interface RootNode {\n  root: Nullable<Node>\n}\n\nexport interface GeoSearchResult {\n  point: Point\n  docIDs: InternalDocumentID[]\n}\n\nexport type SortGeoPoints = Nullable<GenericSorting>\n\ninterface SearchTask {\n  node: Nullable<Node>\n  depth: number\n}\n\nconst K = 2 // 2D points\nconst EARTH_RADIUS = 6371e3 // Earth radius in meters\n\nexport function create(): RootNode {\n  return { root: null }\n}\n\nexport function insert(tree: RootNode, point: Point, docIDs: InternalDocumentID[]): void {\n  const newNode: Node = { point, docIDs }\n\n  if (tree.root == null) {\n    tree.root = newNode\n    return\n  }\n\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    // Check if the current node's point matches the new point\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // Merge the new docIDs with the existing ones and remove duplicates\n      const newDocIDs = node.docIDs ?? []\n      node.docIDs = Array.from(new Set([...newDocIDs, ...(docIDs || [])]))\n      return\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n      // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function contains(tree: RootNode, point: Point): boolean {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n\n  while (node != null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      return true\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n      // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n    }\n\n    depth++\n  }\n\n  return false\n}\n\n// @todo: this is very inefficient. Fix this later.\nexport function removeDocByID(tree: RootNode, point: Point, docID: InternalDocumentID): void {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n  let parentNode: Nullable<Node> = null\n  let direction: 'left' | 'right' | null = null\n\n  while (node !== null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      const index = node.docIDs?.indexOf(docID)\n      if (index !== undefined && index > -1) {\n        // Remove the docID from the array\n        node.docIDs?.splice(index, 1)\n\n        if (node.docIDs == null || node.docIDs.length === 0) {\n          // If the node doesn't have any more docIDs, remove the node\n          if (parentNode != null) {\n            if (direction === 'left') {\n              parentNode.left = node.left !== null ? node.left : node.right\n            } else if (direction === 'right') {\n              parentNode.right = node.right !== null ? node.right : node.left\n            }\n          } else {\n            // If the node to be removed is the root\n            tree.root = (node.left !== null ? node.left : node.right) as Node\n          }\n        }\n\n        return\n      }\n    }\n\n    const axis = depth % K\n\n    parentNode = node as Nullable<Node>\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node!.point.lon) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n      // Compare by latitude\n    } else {\n      if (point.lat < node!.point.lat) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function getDocIDsByCoordinates(tree: RootNode, point: Point): Nullable<InternalDocumentID[]> {\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // prettier-ignore\n      return node.docIDs ?? null\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n      // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n    }\n\n    depth++\n  }\n\n  return null\n}\n\nexport function searchByRadius(\n  node: Nullable<Node>,\n  center: Point,\n  radius: number,\n  inclusive = true,\n  sort: SortGeoPoints = 'asc',\n  highPrecision = false\n): GeoSearchResult[] {\n  const distanceFn = highPrecision ? vincentyDistance : haversineDistance\n  const stack: Array<{ node: Nullable<Node>; depth: number }> = [{ node, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const { node, depth } = stack.pop() as { node: Node; depth: number }\n    if (node === null) continue\n\n    const dist = distanceFn(center, node.point)\n\n    if (inclusive ? dist <= radius : dist > radius) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: depth + 1 })\n    }\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: depth + 1 })\n    }\n  }\n\n  if (sort) {\n    result.sort((a, b) => {\n      const distA = distanceFn(center, a.point)\n      const distB = distanceFn(center, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nexport function searchByPolygon(\n  root: Nullable<Node>,\n  polygon: Point[],\n  inclusive = true,\n  sort: SortGeoPoints = null,\n  highPrecision = false\n): GeoSearchResult[] {\n  const stack: SearchTask[] = [{ node: root, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const task = stack.pop()\n    if (task == null || task.node == null) continue\n\n    const { node, depth } = task\n    const nextDepth = depth + 1\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: nextDepth })\n    }\n\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: nextDepth })\n    }\n\n    const isInsidePolygon = isPointInPolygon(polygon, node.point)\n\n    if (isInsidePolygon && inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    } else if (!isInsidePolygon && !inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n  }\n\n  const centroid = calculatePolygonCentroid(polygon)\n\n  if (sort) {\n    const sortFn = highPrecision ? vincentyDistance : haversineDistance\n\n    result.sort((a, b) => {\n      const distA = sortFn(centroid, a.point)\n      const distB = sortFn(centroid, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nfunction calculatePolygonCentroid(polygon: Point[]): Point {\n  let totalArea = 0\n  let centroidX = 0\n  let centroidY = 0\n\n  const polygonLength = polygon.length\n  for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {\n    const xi = polygon[i].lon\n    const yi = polygon[i].lat\n    const xj = polygon[j].lon\n    const yj = polygon[j].lat\n\n    const areaSegment = xi * yj - xj * yi\n    totalArea += areaSegment\n\n    centroidX += (xi + xj) * areaSegment\n    centroidY += (yi + yj) * areaSegment\n  }\n\n  totalArea /= 2\n  const centroidCoordinate = 6 * totalArea\n\n  centroidX /= centroidCoordinate\n  centroidY /= centroidCoordinate\n\n  return { lon: centroidX, lat: centroidY }\n}\n\nfunction isPointInPolygon(polygon: Point[], point: Point): boolean {\n  let isInside = false\n  const x = point.lon\n  const y = point.lat\n  const polygonLength = polygon.length\n  for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {\n    const xi = polygon[i].lon\n    const yi = polygon[i].lat\n    const xj = polygon[j].lon\n    const yj = polygon[j].lat\n\n    const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi\n    if (intersect) isInside = !isInside\n  }\n\n  return isInside\n}\n\nfunction haversineDistance(coord1: Point, coord2: Point): number {\n  const P = Math.PI / 180\n  const lat1 = coord1.lat * P\n  const lat2 = coord2.lat * P\n  const deltaLat = (coord2.lat - coord1.lat) * P\n  const deltaLon = (coord2.lon - coord1.lon) * P\n\n  const a =\n    Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n    Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n\n  return EARTH_RADIUS * c\n}\n\nfunction vincentyDistance(coord1: Point, coord2: Point): number {\n  // Constants for WGS 84 ellipsoidal Earth model (https://epsg.org/ellipsoid_7030/WGS-84.html)\n\n  // Semi-major axis of the Earth in meters\n  const a = 6378137\n\n  // Flattening of the ellipsoid\n  const f = 1 / 298.257223563\n\n  // Semi-minor axis\n  const b = (1 - f) * a\n\n  // Convert degrees to radians for calculations\n  const P = Math.PI / 180\n  const lat1 = coord1.lat * P\n  const lat2 = coord2.lat * P\n  const deltaLon = (coord2.lon - coord1.lon) * P\n\n  // Reduced latitudes - account for flattening by transforming from geodetic to auxiliary latitude\n  const U1 = Math.atan((1 - f) * Math.tan(lat1))\n  const U2 = Math.atan((1 - f) * Math.tan(lat2))\n\n  const sinU1 = Math.sin(U1)\n  const cosU1 = Math.cos(U1)\n  const sinU2 = Math.sin(U2)\n  const cosU2 = Math.cos(U2)\n\n  // Initial approximation for the longitude difference between the two points\n  let lambda = deltaLon\n  let prevLambda: number\n\n  // Limit the iterations to ensure we don't get stuck in an infinite loop\n  let iterationLimit = 1000\n  let sinAlpha: number\n  let cos2Alpha: number\n  let sinSigma: number\n  let cosSigma: number\n  let sigma: number\n\n  // Refine the value of lambda (longitude difference)\n  do {\n    const sinLambda = Math.sin(lambda)\n    const cosLambda = Math.cos(lambda)\n\n    // Compute the trigonometric values required for Vincenty formulae\n    sinSigma = Math.sqrt(\n      cosU2 * sinLambda * (cosU2 * sinLambda) +\n        (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)\n    )\n\n    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n    sigma = Math.atan2(sinSigma, cosSigma)\n\n    // Angular separation between the two points and the equator\n    sinAlpha = (cosU1 * cosU2 * sinLambda) / sinSigma\n    cos2Alpha = 1 - sinAlpha * sinAlpha\n\n    const cos2SigmaM = cosSigma - (2 * sinU1 * sinU2) / cos2Alpha\n\n    // Compensation factor for the Earth's shape\n    const C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha))\n\n    // Store previous lambda to check for convergence\n    prevLambda = lambda\n\n    // Refine the estimate of lambda using the Vincenty formula\n    lambda =\n      deltaLon +\n      (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)))\n  } while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0)\n\n  // Compute factors that depend on the shape of the Earth and angular distances\n  const u2 = (cos2Alpha * (a * a - b * b)) / (b * b)\n  const A = 1 + (u2 / 16384) * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)))\n  const B = (u2 / 1024) * (256 + u2 * (-128 + u2 * (74 - 47 * u2)))\n\n  // Compute the correction factor for the ellipsoidal shape of the Earth\n  const deltaSigma =\n    B *\n    sinSigma *\n    (cosSigma -\n      (2 * sinU1 * sinU2) / cos2Alpha +\n      (B / 4) *\n        (cosSigma * (-1 + 2 * sinSigma * sinSigma) -\n          (B / 6) * sigma * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * sigma * sigma)))\n\n  // Final calculation of distance using Vincenty formula\n  const s = b * A * (sigma - deltaSigma)\n\n  return s\n}\n"],"names":["K","EARTH_RADIUS","create","root","insert","tree","point","docIDs","newNode","node","depth","lon","lat","newDocIDs","Array","from","Set","axis","left","right","contains","removeDocByID","docID","parentNode","direction","index","indexOf","undefined","splice","length","getDocIDsByCoordinates","searchByRadius","center","radius","inclusive","sort","highPrecision","distanceFn","vincentyDistance","haversineDistance","stack","result","pop","dist","push","a","b","distA","distB","toLowerCase","searchByPolygon","polygon","task","nextDepth","isInsidePolygon","isPointInPolygon","centroid","calculatePolygonCentroid","sortFn","totalArea","centroidX","centroidY","polygonLength","i","j","xi","yi","xj","yj","areaSegment","centroidCoordinate","isInside","x","y","intersect","coord1","coord2","P","Math","PI","lat1","lat2","deltaLat","deltaLon","sin","cos","c","atan2","sqrt","f","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","lambda","prevLambda","iterationLimit","sinAlpha","cos2Alpha","sinSigma","cosSigma","sigma","sinLambda","cosLambda","cos2SigmaM","C","abs","u2","A","B","deltaSigma","s"],"mappings":"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"}},
    {"offset": {"line": 2128, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/algorithms.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { TokenScore, BM25Params } from '../types.js'\nimport { InternalDocumentID } from './internal-document-id-store.js'\n\nexport function prioritizeTokenScores(\n  arrays: TokenScore[][],\n  boost: number,\n  threshold = 0,\n  keywordsCount: number\n): TokenScore[] {\n  if (boost === 0) {\n    throw createError('INVALID_BOOST_VALUE')\n  }\n\n  const tokenScoresMap = new Map<InternalDocumentID, [number, number]>()\n\n  const mapsLength = arrays.length\n  for (let i = 0; i < mapsLength; i++) {\n    const arr = arrays[i]\n\n    const entriesLength = arr.length\n    for (let j = 0; j < entriesLength; j++) {\n      const [token, score] = arr[j]\n      const boostScore = score * boost\n      const oldScore = tokenScoresMap.get(token)?.[0]\n\n      if (oldScore !== undefined) {\n        tokenScoresMap.set(token, [oldScore * 1.5 + boostScore, (tokenScoresMap?.get(token)?.[1] || 0) + 1])\n      } else {\n        tokenScoresMap.set(token, [boostScore, 1])\n      }\n    }\n  }\n\n  const tokenScores: TokenScore[] = []\n\n  for (const tokenScoreEntry of tokenScoresMap.entries()) {\n    tokenScores.push([tokenScoreEntry[0], tokenScoreEntry[1][0]])\n  }\n\n  const results = tokenScores.sort((a, b) => b[1] - a[1])\n\n  // If threshold is 1, it means we will return all the results with at least one search term,\n  // prioritizig the ones that contains more search terms (fuzzy match)\n  if (threshold === 1) {\n    return results\n  }\n\n  // Prepare keywords count tracking for threshold handling\n  const allResults = results.length\n  const tokenScoreWithKeywordsCount: [InternalDocumentID, number, number][] = []\n\n  for (const tokenScoreEntry of tokenScoresMap.entries()) {\n    tokenScoreWithKeywordsCount.push([tokenScoreEntry[0], tokenScoreEntry[1][0], tokenScoreEntry[1][1]])\n  }\n\n  // Find the index of the last result with all keywords.\n  // Order the documents by the number of keywords they contain, and then by the score.\n  const keywordsPerToken = tokenScoreWithKeywordsCount.sort((a, b) => {\n    // Compare by the third element, higher numbers first\n    if (a[2] > b[2]) return -1\n    if (a[2] < b[2]) return 1\n\n    // If the third elements are equal, compare by the second element, higher numbers first\n    if (a[1] > b[1]) return -1\n    if (a[1] < b[1]) return 1\n\n    // If both the second and third elements are equal, consider the elements equal\n    return 0\n  })\n\n  let lastTokenWithAllKeywords: number | undefined = undefined\n  for (let i = 0; i < allResults; i++) {\n    if (keywordsPerToken[i][2] === keywordsCount) {\n      lastTokenWithAllKeywords = i\n    } else {\n      break\n    }\n  }\n\n  // If no results had all the keywords, either bail out earlier or normalize\n  if (typeof lastTokenWithAllKeywords === 'undefined') {\n    if (threshold === 0) {\n      return []\n    }\n\n    lastTokenWithAllKeywords = 0\n  }\n\n  const keywordsPerTokenLength = keywordsPerToken.length\n  const resultsWithIdAndScore: [number, number][] = new Array(keywordsPerTokenLength)\n  for (let i = 0; i < keywordsPerTokenLength; i++) {\n    resultsWithIdAndScore[i] = [keywordsPerToken[i][0], keywordsPerToken[i][1]]\n  }\n\n  // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)\n  if (threshold === 0) {\n    return resultsWithIdAndScore.slice(0, lastTokenWithAllKeywords + 1)\n  }\n\n  // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms\n  // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms\n  // (fuzzy match with a minimum threshold)\n  const thresholdLength =\n    lastTokenWithAllKeywords + Math.ceil((threshold * 100 * (allResults - lastTokenWithAllKeywords)) / 100)\n\n  return resultsWithIdAndScore.slice(0, allResults + thresholdLength)\n}\n\nexport function BM25(\n  tf: number,\n  matchingCount: number,\n  docsCount: number,\n  fieldLength: number,\n  averageFieldLength: number,\n  { k, b, d }: Required<BM25Params>\n) {\n  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5))\n  return (idf * (d + tf * (k + 1))) / (tf + k * (1 - b + (b * fieldLength) / averageFieldLength))\n}\n"],"names":["createError","prioritizeTokenScores","arrays","boost","threshold","keywordsCount","tokenScoresMap","Map","mapsLength","length","i","arr","entriesLength","j","token","score","boostScore","oldScore","get","undefined","set","tokenScores","tokenScoreEntry","entries","push","results","sort","a","b","allResults","tokenScoreWithKeywordsCount","keywordsPerToken","lastTokenWithAllKeywords","keywordsPerTokenLength","resultsWithIdAndScore","Array","slice","thresholdLength","Math","ceil","BM25","tf","matchingCount","docsCount","fieldLength","averageFieldLength","k","d","idf","log"],"mappings":"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"}},
    {"offset": {"line": 2240, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/cosine-similarity.ts"],"sourcesContent":["import type { Magnitude, VectorType } from '../types.js'\n\nexport type SimilarVector = [string, number]\n\nexport function getMagnitude(vector: Float32Array, vectorLength: number): number {\n  let magnitude = 0\n  for (let i = 0; i < vectorLength; i++) {\n    magnitude += vector[i] * vector[i]\n  }\n  return Math.sqrt(magnitude)\n}\n\n// @todo: Write plugins for Node and Browsers to use parallel computation for this function\nexport function findSimilarVectors(\n  targetVector: Float32Array,\n  vectors: Record<string, [Magnitude, VectorType]>,\n  length: number,\n  threshold = 0.8\n): SimilarVector[] {\n  const targetMagnitude = getMagnitude(targetVector, length)\n\n  const similarVectors: SimilarVector[] = []\n\n  for (const [vectorId, [magnitude, vector]] of Object.entries(vectors)) {\n    let dotProduct = 0\n\n    for (let i = 0; i < length; i++) {\n      dotProduct += targetVector[i] * vector[i]\n    }\n\n    const similarity = dotProduct / (targetMagnitude * magnitude)\n\n    if (similarity >= threshold) {\n      similarVectors.push([vectorId, similarity])\n    }\n  }\n\n  return similarVectors.sort((a, b) => b[1] - a[1])\n}\n"],"names":["getMagnitude","vector","vectorLength","magnitude","i","Math","sqrt","findSimilarVectors","targetVector","vectors","length","threshold","targetMagnitude","similarVectors","vectorId","Object","entries","dotProduct","similarity","push","sort","a","b"],"mappings":";;;;;;AAIO,SAASA,aAAaC,MAAoB,EAAEC,YAAoB,EAAU;IAC/E,IAAIC,YAAY;IAChB,IAAK,IAAIC,IAAI,GAAGA,IAAIF,cAAcE,IAAK;QACrCD,aAAaF,MAAM,CAACG,EAAE,GAAGH,MAAM,CAACG,EAAE;IACpC;IACA,OAAOC,KAAKC,IAAI,CAACH;AACnB,CAAC;AAGM,SAASI,mBACdC,YAA0B,EAC1BC,OAAgD,EAChDC,MAAc,EACdC,YAAY,GAAG,EACE;IACjB,MAAMC,kBAAkBZ,aAAaQ,cAAcE;IAEnD,MAAMG,iBAAkC,EAAE;IAE1C,KAAK,MAAM,CAACC,UAAU,CAACX,WAAWF,OAAO,CAAC,IAAIc,OAAOC,OAAO,CAACP,SAAU;QACrE,IAAIQ,aAAa;QAEjB,IAAK,IAAIb,IAAI,GAAGA,IAAIM,QAAQN,IAAK;YAC/Ba,cAAcT,YAAY,CAACJ,EAAE,GAAGH,MAAM,CAACG,EAAE;QAC3C;QAEA,MAAMc,aAAaD,aAAcL,CAAAA,kBAAkBT,SAAQ;QAE3D,IAAIe,cAAcP,WAAW;YAC3BE,eAAeM,IAAI,CAAC;gBAACL;gBAAUI;aAAW;QAC5C,CAAC;IACH;IAEA,OAAOL,eAAeO,IAAI,CAAC,CAACC,GAAGC,IAAMA,CAAC,CAAC,EAAE,GAAGD,CAAC,CAAC,EAAE;AAClD,CAAC"}},
    {"offset": {"line": 2275, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/index.ts"],"sourcesContent":["import type {\n  AnyIndexStore,\n  AnyOrama,\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  EnumArrComparisonOperator,\n  EnumComparisonOperator,\n  GeosearchOperation,\n  GeosearchPolygonOperator,\n  GeosearchRadiusOperator,\n  IIndex,\n  ScalarSearchableType,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  SearchParamsFullText,\n  Tokenizer,\n  TokenScore,\n  TypedDocument,\n  VectorIndex,\n  VectorType,\n  WhereCondition\n} from '../types.js'\nimport type { InsertOptions } from '../methods/insert.js'\nimport { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  RootNode as AVLRootNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument\n} from '../trees/avl.js'\nimport {\n  create as flatCreate,\n  filter as flatFilter,\n  filterArr as flatFilterArr,\n  insert as flatInsert,\n  removeDocument as flatRemoveDocument,\n  FlatTree\n} from '../trees/flat.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument\n} from '../trees/radix.js'\nimport {\n  create as bkdCreate,\n  insert as bkdInsert,\n  removeDocByID as bkdRemoveDocByID,\n  RootNode as BKDNode,\n  Point as BKDGeoPoint,\n  searchByRadius,\n  searchByPolygon\n} from '../trees/bkd.js'\n\nimport { convertDistanceToMeters, intersect, safeArrayPush, getOwnProperty } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getMagnitude } from './cosine-similarity.js'\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport type TreeType = 'AVL' | 'Radix' | 'Bool' | 'Flat' | 'BKD'\n\nexport type TTree<T = TreeType, N = unknown> = {\n  type: T\n  node: N\n  isArray: boolean\n}\n\nexport type Tree =\n  | TTree<'Radix', RadixNode>\n  | TTree<'AVL', AVLRootNode<number, InternalDocumentID[]>>\n  | TTree<'Bool', BooleanIndex>\n  | TTree<'Flat', FlatTree>\n  | TTree<'BKD', BKDNode>\n\nexport interface Index extends AnyIndexStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, Tree>\n  vectorIndexes: Record<string, VectorIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (docsCount > 1) {\n    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1);\n  } else {\n    index.avgFieldLength[prop] = undefined as unknown as number;\n  }\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument, SearchParamsFullText<T, ResultDocument>>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[]\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create<T extends AnyOrama, TSchema extends T['schema']>(\n  orama: T,\n  sharedInternalDocumentStore: T['internalDocumentIDStore'],\n  schema: TSchema,\n  index?: Index,\n  prefix = ''\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {}\n    }\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path)\n      continue\n    }\n\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {}\n      }\n    } else {\n      const isArray = /\\[/.test(type as string)\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = { type: 'Bool', node: { true: [], false: [] }, isArray }\n          break\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = { type: 'AVL', node: avlCreate<number, InternalDocumentID[]>(0, []), isArray }\n          break\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = { type: 'Radix', node: radixCreate(), isArray }\n          index.avgFieldLength[path] = 0\n          index.frequencies[path] = {}\n          index.tokenOccurrences[path] = {}\n          index.fieldLengths[path] = {}\n          break\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = { type: 'Flat', node: flatCreate(), isArray }\n          break\n        case 'geopoint':\n          index.indexes[path] = { type: 'BKD', node: bkdCreate(), isArray }\n          break\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n    }\n  }\n\n  return index\n}\n\nfunction insertScalarBuilder(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n  options?: InsertOptions\n) {\n  return async (value: SearchableValue): Promise<void> => {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n    const { type, node } = index.indexes[prop]\n    switch (type) {\n      case 'Bool': {\n        node[value ? 'true' : 'false'].push(internalId)\n        break\n      }\n      case 'AVL': {\n        const avlRebalanceThreshold = options?.avlRebalanceThreshold ?? 1\n        avlInsert(node, value as number, [internalId], avlRebalanceThreshold)\n        break\n      }\n      case 'Radix': {\n        const tokens = await tokenizer.tokenize(value as string, language, prop)\n        await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n        for (const token of tokens) {\n          await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n          radixInsert(node, token, internalId)\n        }\n\n        break\n      }\n      case 'Flat': {\n        flatInsert(node, value as ScalarSearchableType, internalId)\n        break\n      }\n      case 'BKD': {\n        bkdInsert(node, value as unknown as BKDGeoPoint, [internalId])\n        break\n      }\n    }\n  }\n}\n\nexport async function insert(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n  options?: InsertOptions\n): Promise<void> {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value as number[] | Float32Array, id)\n  }\n\n  const insertScalar = insertScalarBuilder(implementation, index, prop, id, language, tokenizer, docsCount, options)\n\n  if (!isArrayType(schemaType)) {\n    return insertScalar(value)\n  }\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(elements[i])\n  }\n}\n\nfunction insertVector(index: Index, prop: string, value: number[] | VectorType, id: DocumentID): void {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value)\n  }\n\n  const size = index.vectorIndexes[prop].size\n  const magnitude = getMagnitude(value, size)\n\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value]\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id]\n    return true\n  }\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'AVL': {\n      avlRemoveDocument(node, internalId, value as number)\n      return true\n    }\n    case 'Bool': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = node[booleanKey].indexOf(internalId)\n\n      node[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(node, token, internalId)\n      }\n\n      return true\n    }\n    case 'Flat': {\n      flatRemoveDocument(node, internalId, value as ScalarSearchableType)\n      return true\n    }\n    case 'BKD': {\n      bkdRemoveDocByID(node, value as unknown as BKDGeoPoint, internalId)\n      return false\n    }\n  }\n}\n\nexport async function remove(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument, SearchParamsFullText<T, ResultDocument>>,\n  index: Index,\n  prop: string,\n  term: string\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  const { node, type } = index.indexes[prop]\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop)\n  }\n\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(node, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    //skip keys inherited from prototype\n    const ownProperty = getOwnProperty(searchResult, key)\n    if (!ownProperty) continue\n\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  filters: Partial<WhereCondition<T['schema']>>\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc\n    }),\n    {}\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]!\n\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    const { node, type, isArray } = index.indexes[param]\n\n    if (type === 'Bool') {\n      const idx = node\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      safeArrayPush(filtersMap[param], filteredIDs)\n      continue\n    }\n\n    if (type === 'BKD') {\n      let reqOperation: 'radius' | 'polygon'\n\n      if ('radius' in (operation as GeosearchOperation)) {\n        reqOperation = 'radius'\n      } else if ('polygon' in (operation as GeosearchOperation)) {\n        reqOperation = 'polygon'\n      } else {\n        throw new Error(`Invalid operation ${operation}`)\n      }\n\n      if (reqOperation === 'radius') {\n        const {\n          value,\n          coordinates,\n          unit = 'm',\n          inside = true,\n          highPrecision = false\n        } = operation[reqOperation] as GeosearchRadiusOperator['radius']\n        const distanceInMeters = convertDistanceToMeters(value, unit)\n        const ids = searchByRadius(\n          node.root,\n          coordinates as BKDGeoPoint,\n          distanceInMeters,\n          inside,\n          undefined,\n          highPrecision\n        )\n        // @todo: convert this into a for loop\n        safeArrayPush(\n          filtersMap[param],\n          ids.flatMap(({ docIDs }) => docIDs)\n        )\n      } else {\n        const {\n          coordinates,\n          inside = true,\n          highPrecision = false\n        } = operation[reqOperation] as GeosearchPolygonOperator['polygon']\n        const ids = searchByPolygon(node.root, coordinates as BKDGeoPoint[], inside, undefined, highPrecision)\n        // @todo: convert this into a for loop\n        safeArrayPush(\n          filtersMap[param],\n          ids.flatMap(({ docIDs }) => docIDs)\n        )\n      }\n\n      continue\n    }\n\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, { term: t, exact: true })\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat())\n        }\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    if (type === 'Flat') {\n      const flatOperation = isArray ? flatFilterArr : flatFilter\n      safeArrayPush(\n        filtersMap[param],\n        flatOperation(node, operation as EnumComparisonOperator & EnumArrComparisonOperator)\n      )\n\n      continue\n    }\n\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0] as keyof ComparisonOperator\n      const operationValue = (operation as ComparisonOperator)[operationOpt]\n      let filteredIDs: InternalDocumentID[] = []\n\n      switch (operationOpt) {\n        case 'gt': {\n          filteredIDs = avlGreaterThan(node, operationValue, false)\n          break\n        }\n        case 'gte': {\n          filteredIDs = avlGreaterThan(node, operationValue, true)\n          break\n        }\n        case 'lt': {\n          filteredIDs = avlLessThan(node, operationValue, false)\n          break\n        }\n        case 'lte': {\n          filteredIDs = avlLessThan(node, operationValue, true)\n          break\n        }\n        case 'eq': {\n          filteredIDs = avlFind(node, operationValue) ?? []\n          break\n        }\n        case 'between': {\n          const [min, max] = operationValue as number[]\n          filteredIDs = avlRangeSearch(node, min, max)\n          break\n        }\n      }\n\n      safeArrayPush(filtersMap[param], filteredIDs)\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  return intersect(Object.values(filtersMap))\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadRadixNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.e, node.s, node.k)\n\n  convertedNode.d = node.d\n  convertedNode.w = node.w\n\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey])\n  }\n\n  return convertedNode\n}\n\nfunction loadFlatNode(node: unknown): FlatTree {\n  return {\n    numberToDocumentId: new Map(node as [ScalarSearchableType, InternalDocumentID[]][])\n  }\n}\n\nfunction saveFlatNode(node: FlatTree): unknown {\n  return Array.from(node.numberToDocumentId.entries())\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n  const vectorIndexes: Index['vectorIndexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const { node, type, isArray } = rawIndexes[prop]\n\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        }\n        break\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        }\n        break\n      default:\n        indexes[prop] = rawIndexes[prop]\n    }\n  }\n\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])]\n    }\n\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors\n    }\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = index\n\n  const vectorIndexesAsArrays: Index['vectorIndexes'] = {}\n\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1]) as unknown as Float32Array]\n    }\n\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes: any = {}\n  for (const name of Object.keys(indexes)) {\n    const { type, node, isArray } = indexes[name]\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name]\n      continue\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray\n    }\n  }\n\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } as R\n}\n\nexport async function createIndex(): Promise<IIndex<Index>> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save\n  }\n}\n"],"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","flatCreate","filter","flatFilter","filterArr","flatFilterArr","flatInsert","flatRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","bkdCreate","bkdInsert","removeDocByID","bkdRemoveDocByID","searchByRadius","searchByPolygon","convertDistanceToMeters","intersect","safeArrayPush","getOwnProperty","BM25","getMagnitude","getInnerType","getVectorSize","isArrayType","isVectorType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","bm25","params","relevance","push","orama","schema","prefix","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","path","isArray","size","vectors","test","node","true","false","insertScalarBuilder","implementation","language","tokenizer","options","value","avlRebalanceThreshold","tokenize","schemaType","insertVector","insertScalar","elements","elementsLength","i","Float32Array","magnitude","removeScalar","booleanKey","position","indexOf","splice","remove","innerSchemaType","search","exact","tolerance","searchResult","Set","key","ownProperty","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","reqOperation","Error","coordinates","unit","inside","highPrecision","distanceInMeters","root","flatMap","docIDs","raw","flat","filteredIDsResults","values","operationKeys","flatOperation","operationOpt","operationValue","min","max","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","e","s","d","w","childrenKey","c","loadFlatNode","numberToDocumentId","Map","saveFlatNode","load","rawIndexes","rawVectorIndexes","vec","save","vectorIndexesAsArrays","savedIndexes","name","createIndex"],"mappings":"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"}},
    {"offset": {"line": 2863, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/sorter.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport {\n  AnyOrama,\n  AnySorterStore,\n  ISorter,\n  SearchableType,\n  SorterConfig,\n  SorterParams,\n  SortType,\n  SortValue\n} from '../types.js'\nimport { isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore\n} from './internal-document-id-store.js'\nimport { safeArrayPush } from '../utils.js'\nimport { getLocale } from './tokenizer/languages.js'\n\ninterface PropertySort<K> {\n  docs: Map<InternalDocumentID, number>\n  orderedDocs: [InternalDocumentID, K][]\n  orderedDocsToRemove: Map<InternalDocumentID, boolean>\n  type: SortType\n}\n\ntype SerializablePropertySort<K> = Omit<PropertySort<K>, 'orderedDocsToRemove' | 'docs'> & {\n  docs: Record<string, number>\n}\n\nexport interface Sorter extends AnySorterStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  isSorted: boolean\n  language: string\n  enabled: boolean\n  sortableProperties: string[]\n  sortablePropertiesWithTypes: Record<string, SortType>\n  sorts: Record<string, PropertySort<number | string | boolean>>\n}\n\nfunction innerCreate<T extends AnyOrama>(\n  orama: T,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: T['schema'],\n  sortableDeniedProperties: string[],\n  prefix: string\n): Sorter {\n  const sorter: Sorter = {\n    language: orama.tokenizer.language,\n    sharedInternalDocumentStore,\n    enabled: true,\n    isSorted: true,\n    sortableProperties: [],\n    sortablePropertiesWithTypes: {},\n    sorts: {}\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (sortableDeniedProperties.includes(path)) {\n      continue\n    }\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path)\n      safeArrayPush(sorter.sortableProperties, ret.sortableProperties)\n      sorter.sorts = {\n        ...sorter.sorts,\n        ...ret.sorts\n      }\n      sorter.sortablePropertiesWithTypes = {\n        ...sorter.sortablePropertiesWithTypes,\n        ...ret.sortablePropertiesWithTypes\n      }\n      continue\n    }\n\n    if (!isVectorType(type)) {\n      switch (type) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n          sorter.sortableProperties.push(path)\n          sorter.sortablePropertiesWithTypes[path] = type\n          sorter.sorts[path] = {\n            docs: new Map(),\n            orderedDocsToRemove: new Map(),\n            orderedDocs: [],\n            type: type\n          }\n          break\n        case 'geopoint':\n        case 'enum':\n          // We don't allow to sort by enums or geopoints\n          continue\n        case 'enum[]':\n        case 'boolean[]':\n        case 'number[]':\n        case 'string[]':\n          // We don't allow to sort by arrays\n          continue\n        default:\n          throw createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n    }\n  }\n\n  return sorter\n}\n\nasync function create<T extends AnyOrama>(\n  orama: T,\n  sharedInternalDocumentStore: InternalDocumentIDStore,\n  schema: T['schema'],\n  config?: SorterConfig\n): Promise<Sorter> {\n  const isSortEnabled = config?.enabled !== false\n  if (!isSortEnabled) {\n    return {\n      disabled: true\n    } as unknown as Sorter\n  }\n  return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '')\n}\n\nasync function insert(sorter: Sorter, prop: string, id: DocumentID, value: SortValue): Promise<void> {\n  if (!sorter.enabled) {\n    return\n  }\n\n  sorter.isSorted = false\n\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n  const s = sorter.sorts[prop]\n\n  // This happen during a document updating\n  // Because we re-use the same internalId\n  // We need to clean-up the data structure before re-inserting\n  // to avoid duplicates in the orderedDocs array\n  // See: https://github.com/askorama/orama/issues/629\n  if (s.orderedDocsToRemove.has(internalId)) {\n    ensureOrderedDocsAreDeletedByProperty(sorter, prop)\n  }\n\n  s.docs.set(internalId, s.orderedDocs.length)\n  s.orderedDocs.push([internalId, value])\n}\n\nfunction ensureIsSorted(sorter: Sorter): void {\n  if (sorter.isSorted || !sorter.enabled) {\n    return\n  }\n\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensurePropertyIsSorted(sorter, prop)\n  }\n\n  sorter.isSorted = true\n}\n\nfunction stringSort(\n  language: string | undefined,\n  value: [InternalDocumentID, SortValue],\n  d: [InternalDocumentID, SortValue]\n): number {\n  return (value[1] as string).localeCompare(d[1] as string, getLocale(language))\n}\n\nfunction numberSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (value[1] as number) - (d[1] as number)\n}\n\nfunction booleanSort(value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]): number {\n  return (d[1] as boolean) ? -1 : 1\n}\n\nfunction ensurePropertyIsSorted(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  let predicate: (value: [InternalDocumentID, SortValue], d: [InternalDocumentID, SortValue]) => number\n  switch (s.type) {\n    case 'string':\n      predicate = stringSort.bind(null, sorter.language)\n      break\n    case 'number':\n      predicate = numberSort.bind(null)\n      break\n    case 'boolean':\n      predicate = booleanSort.bind(null)\n      break\n  }\n\n  s.orderedDocs.sort(predicate)\n\n  // Increment position for the greather documents\n  const orderedDocsLength = s.orderedDocs.length\n  for (let i = 0; i < orderedDocsLength; i++) {\n    const docId = s.orderedDocs[i][0]\n    s.docs.set(docId, i)\n  }\n}\n\nfunction ensureOrderedDocsAreDeleted(sorter: Sorter): void {\n  const properties = Object.keys(sorter.sorts)\n  for (const prop of properties) {\n    ensureOrderedDocsAreDeletedByProperty(sorter, prop)\n  }\n}\n\nfunction ensureOrderedDocsAreDeletedByProperty(sorter: Sorter, prop: string): void {\n  const s = sorter.sorts[prop]\n\n  if (!s.orderedDocsToRemove.size) return\n\n  s.orderedDocs = s.orderedDocs.filter((doc) => !s.orderedDocsToRemove.has(doc[0]))\n  s.orderedDocsToRemove.clear()\n}\n\nasync function remove(sorter: Sorter, prop: string, id: DocumentID) {\n  if (!sorter.enabled) {\n    return\n  }\n  const s = sorter.sorts[prop] as PropertySort<SortValue>\n  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id)\n\n  const index = s.docs.get(internalId)\n\n  if (!index) return\n\n  s.docs.delete(internalId)\n  s.orderedDocsToRemove.set(internalId, true)\n}\n\nasync function sortBy<T extends AnyOrama>(\n  sorter: Sorter,\n  docIds: [DocumentID, number][],\n  by: SorterParams<T>\n): Promise<[DocumentID, number][]> {\n  if (!sorter.enabled) {\n    throw createError('SORT_DISABLED')\n  }\n\n  const property = by.property\n  const isDesc = by.order === 'DESC'\n\n  const s = sorter.sorts[property]\n  if (!s) {\n    throw createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '))\n  }\n\n  ensureOrderedDocsAreDeletedByProperty(sorter, property)\n  ensureIsSorted(sorter)\n\n  docIds.sort((a, b) => {\n    // This sort algorithm works leveraging on\n    // that s.docs is a map of docId -> position\n    // If a document is not indexed, it will be not present in the map\n    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]))\n    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]))\n    const isAIndexed = typeof indexOfA !== 'undefined'\n    const isBIndexed = typeof indexOfB !== 'undefined'\n\n    if (!isAIndexed && !isBIndexed) {\n      return 0\n    }\n    // unindexed documents are always at the end\n    if (!isAIndexed) {\n      return 1\n    }\n    if (!isBIndexed) {\n      return -1\n    }\n\n    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB\n  })\n\n  return docIds\n}\n\nasync function getSortableProperties(sorter: Sorter): Promise<string[]> {\n  if (!sorter.enabled) {\n    return []\n  }\n\n  return sorter.sortableProperties\n}\n\nasync function getSortablePropertiesWithTypes(sorter: Sorter): Promise<Record<string, SortType>> {\n  if (!sorter.enabled) {\n    return {}\n  }\n\n  return sorter.sortablePropertiesWithTypes\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Sorter> {\n  const rawDocument = raw as Omit<Sorter, 'sorts'> & {\n    sorts: Record<string, SerializablePropertySort<string | number | boolean>>\n  }\n  if (!rawDocument.enabled) {\n    return {\n      enabled: false\n    } as unknown as Sorter\n  }\n\n  const sorts = Object.keys(rawDocument.sorts).reduce(\n    (acc, prop) => {\n      const { docs, orderedDocs, type } = rawDocument.sorts[prop]\n\n      acc[prop] = {\n        docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),\n        orderedDocsToRemove: new Map(),\n        orderedDocs,\n        type\n      }\n\n      return acc\n    },\n    {} as Record<string, PropertySort<string | number | boolean>>\n  )\n\n  return {\n    sharedInternalDocumentStore,\n    language: rawDocument.language,\n    sortableProperties: rawDocument.sortableProperties,\n    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,\n    sorts,\n    enabled: true,\n    isSorted: rawDocument.isSorted\n  }\n}\n\nexport async function save<R = unknown>(sorter: Sorter): Promise<R> {\n  if (!sorter.enabled) {\n    return {\n      enabled: false\n    } as unknown as R\n  }\n\n  ensureOrderedDocsAreDeleted(sorter)\n  ensureIsSorted(sorter)\n\n  const sorts = Object.keys(sorter.sorts).reduce(\n    (acc, prop) => {\n      const { docs, orderedDocs, type } = sorter.sorts[prop]\n\n      acc[prop] = {\n        docs: Object.fromEntries(docs.entries()),\n        orderedDocs,\n        type\n      }\n\n      return acc\n    },\n    {} as Record<string, SerializablePropertySort<string | number | boolean>>\n  )\n\n  return {\n    language: sorter.language,\n    sortableProperties: sorter.sortableProperties,\n    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,\n    sorts,\n    enabled: sorter.enabled,\n    isSorted: sorter.isSorted\n  } as R\n}\n\nexport async function createSorter(): Promise<ISorter<Sorter>> {\n  return {\n    create,\n    insert,\n    remove,\n    save,\n    load,\n    sortBy,\n    getSortableProperties,\n    getSortablePropertiesWithTypes\n  }\n}\n"],"names":["createError","isVectorType","getInternalDocumentId","safeArrayPush","getLocale","innerCreate","orama","sharedInternalDocumentStore","schema","sortableDeniedProperties","prefix","sorter","language","tokenizer","enabled","isSorted","sortableProperties","sortablePropertiesWithTypes","sorts","prop","type","Object","entries","path","includes","Array","isArray","ret","push","docs","Map","orderedDocsToRemove","orderedDocs","create","config","isSortEnabled","disabled","unsortableProperties","insert","id","value","internalId","s","has","ensureOrderedDocsAreDeletedByProperty","set","length","ensureIsSorted","properties","keys","ensurePropertyIsSorted","stringSort","d","localeCompare","numberSort","booleanSort","predicate","bind","sort","orderedDocsLength","i","docId","ensureOrderedDocsAreDeleted","size","filter","doc","clear","remove","index","get","delete","sortBy","docIds","by","property","isDesc","order","join","a","b","indexOfA","indexOfB","isAIndexed","isBIndexed","getSortableProperties","getSortablePropertiesWithTypes","load","raw","rawDocument","reduce","acc","map","k","v","save","fromEntries","createSorter"],"mappings":"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"}},
    {"offset": {"line": 3151, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/tokenizer/diacritics.ts"],"sourcesContent":["const DIACRITICS_CHARCODE_START = 192\nconst DIACRITICS_CHARCODE_END = 383\n\nconst CHARCODE_REPLACE_MAPPING = [\n  65,\n  65,\n  65,\n  65,\n  65,\n  65,\n  65,\n  67,\n  69,\n  69,\n  69,\n  69,\n  73,\n  73,\n  73,\n  73,\n  69,\n  78,\n  79,\n  79,\n  79,\n  79,\n  79,\n  null,\n  79,\n  85,\n  85,\n  85,\n  85,\n  89,\n  80,\n  115,\n  97,\n  97,\n  97,\n  97,\n  97,\n  97,\n  97,\n  99,\n  101,\n  101,\n  101,\n  101,\n  105,\n  105,\n  105,\n  105,\n  101,\n  110,\n  111,\n  111,\n  111,\n  111,\n  111,\n  null,\n  111,\n  117,\n  117,\n  117,\n  117,\n  121,\n  112,\n  121,\n  65,\n  97,\n  65,\n  97,\n  65,\n  97,\n  67,\n  99,\n  67,\n  99,\n  67,\n  99,\n  67,\n  99,\n  68,\n  100,\n  68,\n  100,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  69,\n  101,\n  71,\n  103,\n  71,\n  103,\n  71,\n  103,\n  71,\n  103,\n  72,\n  104,\n  72,\n  104,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  73,\n  105,\n  74,\n  106,\n  75,\n  107,\n  107,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  76,\n  108,\n  78,\n  110,\n  78,\n  110,\n  78,\n  110,\n  110,\n  78,\n  110,\n  79,\n  111,\n  79,\n  111,\n  79,\n  111,\n  79,\n  111,\n  82,\n  114,\n  82,\n  114,\n  82,\n  114,\n  83,\n  115,\n  83,\n  115,\n  83,\n  115,\n  83,\n  115,\n  84,\n  116,\n  84,\n  116,\n  84,\n  116,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  85,\n  117,\n  87,\n  119,\n  89,\n  121,\n  89,\n  90,\n  122,\n  90,\n  122,\n  90,\n  122,\n  115\n]\n\nfunction replaceChar(charCode: number): number {\n  if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END) return charCode\n\n  /* c8 ignore next  */\n  return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode\n}\n\nexport function replaceDiacritics(str: string): string {\n  const stringCharCode: number[] = []\n  for (let idx = 0; idx < str.length; idx++) {\n    stringCharCode[idx] = replaceChar(str.charCodeAt(idx))\n  }\n  return String.fromCharCode(...stringCharCode)\n}\n"],"names":["DIACRITICS_CHARCODE_START","DIACRITICS_CHARCODE_END","CHARCODE_REPLACE_MAPPING","replaceChar","charCode","replaceDiacritics","str","stringCharCode","idx","length","charCodeAt","String","fromCharCode"],"mappings":";;;;AAAA,MAAMA,4BAA4B;AAClC,MAAMC,0BAA0B;AAEhC,MAAMC,2BAA2B;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,SAASC,YAAYC,QAAgB,EAAU;IAC7C,IAAIA,WAAWJ,6BAA6BI,WAAWH,yBAAyB,OAAOG;IAEvF,mBAAmB,GACnB,OAAOF,wBAAwB,CAACE,WAAWJ,0BAA0B,IAAII;AAC3E;AAEO,SAASC,kBAAkBC,GAAW,EAAU;IACrD,MAAMC,iBAA2B,EAAE;IACnC,IAAK,IAAIC,MAAM,GAAGA,MAAMF,IAAIG,MAAM,EAAED,MAAO;QACzCD,cAAc,CAACC,IAAI,GAAGL,YAAYG,IAAII,UAAU,CAACF;IACnD;IACA,OAAOG,OAAOC,YAAY,IAAIL;AAChC,CAAC"}},
    {"offset": {"line": 3366, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/tokenizer/english-stemmer.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\nconst step2List = {\n  ational: 'ate',\n  tional: 'tion',\n  enci: 'ence',\n  anci: 'ance',\n  izer: 'ize',\n  bli: 'ble',\n  alli: 'al',\n  entli: 'ent',\n  eli: 'e',\n  ousli: 'ous',\n  ization: 'ize',\n  ation: 'ate',\n  ator: 'ate',\n  alism: 'al',\n  iveness: 'ive',\n  fulness: 'ful',\n  ousness: 'ous',\n  aliti: 'al',\n  iviti: 'ive',\n  biliti: 'ble',\n  logi: 'log'\n}\n\nconst step3List = {\n  icate: 'ic',\n  ative: '',\n  alize: 'al',\n  iciti: 'ic',\n  ical: 'ic',\n  ful: '',\n  ness: ''\n}\n\n// Consonant\nconst c = '[^aeiou]'\n// Vowel\nconst v = '[aeiouy]'\n// Consonant sequence\nconst C = c + '[^aeiouy]*'\n// Vowel sequence\nconst V = v + '[aeiou]*'\n\n// [C]VC... is m>0\nconst mgr0 = '^(' + C + ')?' + V + C\n// [C]VC[V] is m=1\nconst meq1 = '^(' + C + ')?' + V + C + '(' + V + ')?$'\n// [C]VCVC... is m>1\nconst mgr1 = '^(' + C + ')?' + V + C + V + C\n// vowel in stem\nconst s_v = '^(' + C + ')?' + v\n\nexport function stemmer(w) {\n  let stem\n  let suffix\n  let re\n  let re2\n  let re3\n  let re4\n\n  if (w.length < 3) {\n    return w\n  }\n\n  const firstch = w.substring(0, 1)\n  if (firstch == 'y') {\n    w = firstch.toUpperCase() + w.substring(1)\n  }\n\n  re = /^(.+?)(ss|i)es$/\n  re2 = /^(.+?)([^s])s$/\n\n  if (re.test(w)) {\n    w = w.replace(re, '$1$2')\n  } else if (re2.test(w)) {\n    w = w.replace(re2, '$1$2')\n  }\n\n  re = /^(.+?)eed$/\n  re2 = /^(.+?)(ed|ing)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    re = new RegExp(mgr0)\n    if (re.test(fp[1])) {\n      re = /.$/\n      w = w.replace(re, '')\n    }\n  } else if (re2.test(w)) {\n    const fp = re2.exec(w)\n    stem = fp[1]\n    re2 = new RegExp(s_v)\n    if (re2.test(stem)) {\n      w = stem\n      re2 = /(at|bl|iz)$/\n      re3 = new RegExp('([^aeiouylsz])\\\\1$')\n      re4 = new RegExp('^' + C + v + '[^aeiouwxy]$')\n      if (re2.test(w)) {\n        w = w + 'e'\n      } else if (re3.test(w)) {\n        re = /.$/\n        w = w.replace(re, '')\n      } else if (re4.test(w)) {\n        w = w + 'e'\n      }\n    }\n  }\n\n  re = /^(.+?)y$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(s_v)\n    if (stem && re.test(stem)) {\n      w = stem + 'i'\n    }\n  }\n\n  re =\n    /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    suffix = fp?.[2]\n    re = new RegExp(mgr0)\n    if (stem && re.test(stem)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      w = stem + step2List[suffix]\n    }\n  }\n\n  re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    suffix = fp?.[2]\n    re = new RegExp(mgr0)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (stem && re.test(stem)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      w = stem + step3List[suffix]\n    }\n  }\n\n  re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/\n  re2 = /^(.+?)(s|t)(ion)$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(mgr1)\n    if (stem && re.test(stem)) {\n      w = stem\n    }\n  } else if (re2.test(w)) {\n    const fp = re2.exec(w)\n    stem = fp?.[1] ?? '' + fp?.[2] ?? ''\n    re2 = new RegExp(mgr1)\n    if (re2.test(stem)) {\n      w = stem\n    }\n  }\n\n  re = /^(.+?)e$/\n  if (re.test(w)) {\n    const fp = re.exec(w)\n    stem = fp?.[1]\n    re = new RegExp(mgr1)\n    re2 = new RegExp(meq1)\n    re3 = new RegExp('^' + C + v + '[^aeiouwxy]$')\n    if (stem && (re.test(stem) || (re2.test(stem) && !re3.test(stem)))) {\n      w = stem\n    }\n  }\n\n  re = /ll$/\n  re2 = new RegExp(mgr1)\n  if (re.test(w) && re2.test(w)) {\n    re = /.$/\n    w = w.replace(re, '')\n  }\n\n  if (firstch == 'y') {\n    w = firstch.toLowerCase() + w.substring(1)\n  }\n\n  return w\n}\n"],"names":["step2List","ational","tional","enci","anci","izer","bli","alli","entli","eli","ousli","ization","ation","ator","alism","iveness","fulness","ousness","aliti","iviti","biliti","logi","step3List","icate","ative","alize","iciti","ical","ful","ness","c","v","C","V","mgr0","meq1","mgr1","s_v","stemmer","w","stem","suffix","re","re2","re3","re4","length","firstch","substring","toUpperCase","test","replace","fp","exec","RegExp","toLowerCase"],"mappings":"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"}},
    {"offset": {"line": 3547, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/tokenizer/index.ts"],"sourcesContent":["import { createError } from '../../errors.js'\nimport { Stemmer, Tokenizer, DefaultTokenizerConfig } from '../../types.js'\nimport { replaceDiacritics } from './diacritics.js'\nimport { Language, SPLITTERS, SUPPORTED_LANGUAGES } from './languages.js'\nimport { stemmer as english } from './english-stemmer.js'\n\nexport interface DefaultTokenizer extends Tokenizer {\n  language: Language\n  stemmer?: Stemmer\n  tokenizeSkipProperties: Set<string>\n  stemmerSkipProperties: Set<string>\n  stopWords?: string[]\n  allowDuplicates: boolean\n  normalizationCache: Map<string, string>\n  normalizeToken(this: DefaultTokenizer, token: string, prop: string | undefined): string\n}\n\nexport function normalizeToken(this: DefaultTokenizer, prop: string, token: string): string {\n  const key = `${this.language}:${prop}:${token}`\n\n  if (this.normalizationCache.has(key)) {\n    return this.normalizationCache.get(key)!\n  }\n\n  // Remove stopwords if enabled\n  if (this.stopWords?.includes(token)) {\n    this.normalizationCache.set(key, '')\n    return ''\n  }\n\n  // Apply stemming if enabled\n  if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {\n    token = this.stemmer(token)\n  }\n\n  token = replaceDiacritics(token)\n  this.normalizationCache.set(key, token)\n  return token\n}\n\n/* c8 ignore next 10 */\nfunction trim(text: string[]): string[] {\n  while (text[text.length - 1] === '') {\n    text.pop()\n  }\n  while (text[0] === '') {\n    text.shift()\n  }\n  return text\n}\n\nfunction tokenize(this: DefaultTokenizer, input: string, language?: string, prop?: string): string[] {\n  if (language && language !== this.language) {\n    throw createError('LANGUAGE_NOT_SUPPORTED', language)\n  }\n\n  /* c8 ignore next 3 */\n  if (typeof input !== 'string') {\n    return [input]\n  }\n\n  let tokens: string[]\n  if (prop && this.tokenizeSkipProperties.has(prop)) {\n    tokens = [this.normalizeToken.bind(this, prop ?? '')(input)]\n  } else {\n    const splitRule = SPLITTERS[this.language]\n    tokens = input\n      .toLowerCase()\n      .split(splitRule)\n      .map(this.normalizeToken.bind(this, prop ?? ''))\n      .filter(Boolean)\n  }\n\n  const trimTokens = trim(tokens)\n\n  if (!this.allowDuplicates) {\n    return Array.from(new Set(trimTokens))\n  }\n\n  return trimTokens\n}\n\nexport async function createTokenizer(config: DefaultTokenizerConfig = {}): Promise<DefaultTokenizer> {\n  if (!config.language) {\n    config.language = 'english'\n  } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {\n    throw createError('LANGUAGE_NOT_SUPPORTED', config.language)\n  }\n\n  // Handle stemming - It is disabled by default\n  let stemmer: Stemmer | undefined\n\n  if (config.stemming || (config.stemmer && !('stemming' in config))) {\n    if (config.stemmer) {\n      if (typeof config.stemmer !== 'function') {\n        throw createError('INVALID_STEMMER_FUNCTION_TYPE')\n      }\n\n      stemmer = config.stemmer\n    } else {\n      if (config.language === 'english') {\n        stemmer = english\n      } else {\n        throw createError('MISSING_STEMMER', config.language)\n      }\n    }\n  }\n\n  // Handle stopwords\n  let stopWords: string[] | undefined\n\n  if (config.stopWords !== false) {\n    stopWords = []\n\n    if (Array.isArray(config.stopWords)) {\n      stopWords = config.stopWords\n    } else if (typeof config.stopWords === 'function') {\n      stopWords = await config.stopWords(stopWords)\n    } else if (config.stopWords) {\n      throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n    }\n\n    // Make sure stopWords is just an array of strings\n    if (!Array.isArray(stopWords)) {\n      throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n    }\n\n    for (const s of stopWords) {\n      if (typeof s !== 'string') {\n        throw createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY')\n      }\n    }\n  }\n\n  // Create the tokenizer\n  const tokenizer: DefaultTokenizer = {\n    tokenize,\n    language: config.language,\n    stemmer,\n    stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [config.stemmerSkipProperties].flat() : []),\n    tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [config.tokenizeSkipProperties].flat() : []),\n    stopWords,\n    allowDuplicates: Boolean(config.allowDuplicates),\n    normalizeToken,\n    normalizationCache: new Map()\n  }\n\n  tokenizer.tokenize = tokenize.bind(tokenizer)\n  tokenizer.normalizeToken = normalizeToken\n\n  return tokenizer\n}\n"],"names":["createError","replaceDiacritics","SPLITTERS","SUPPORTED_LANGUAGES","stemmer","english","normalizeToken","prop","token","key","language","normalizationCache","has","get","stopWords","includes","set","stemmerSkipProperties","trim","text","length","pop","shift","tokenize","input","tokens","tokenizeSkipProperties","bind","splitRule","toLowerCase","split","map","filter","Boolean","trimTokens","allowDuplicates","Array","from","Set","createTokenizer","config","stemming","isArray","s","tokenizer","flat","Map"],"mappings":"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"}},
    {"offset": {"line": 3680, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/create.ts"],"sourcesContent":["import { formatElapsedTime, getDocumentIndexId, getDocumentProperties, validateSchema } from '../components/defaults.js'\nimport { DocumentsStore, createDocumentsStore } from '../components/documents-store.js'\nimport { AVAILABLE_PLUGIN_HOOKS, getAllPluginsByHook } from '../components/plugins.js'\nimport { FUNCTION_COMPONENTS, OBJECT_COMPONENTS, runAfterCreate } from '../components/hooks.js'\nimport { Index, createIndex } from '../components/index.js'\nimport { createInternalDocumentIDStore } from '../components/internal-document-id-store.js'\nimport { Sorter, createSorter } from '../components/sorter.js'\nimport { createTokenizer } from '../components/tokenizer/index.js'\nimport { createError } from '../errors.js'\nimport {\n  Components,\n  FunctionComponents,\n  IDocumentsStore,\n  IIndex,\n  ISorter,\n  Orama,\n  OramaPlugin,\n  SorterConfig,\n  Tokenizer\n} from '../types.js'\nimport { uniqueId } from '../utils.js'\n\ninterface CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter> {\n  schema: OramaSchema\n  sort?: SorterConfig\n  language?: string\n  components?: Components<\n    Orama<OramaSchema, TIndex, TDocumentStore, TSorter>,\n    OramaSchema,\n    TIndex,\n    TDocumentStore,\n    TSorter\n  >\n  plugins?: OramaPlugin[]\n  id?: string\n}\n\nfunction validateComponents<\n  OramaSchema,\n  TIndex,\n  TDocumentStore,\n  TSorter,\n  TOrama extends Orama<OramaSchema, TIndex, TDocumentStore, TSorter>\n>(components: Components<TOrama, OramaSchema, TIndex, TDocumentStore, TSorter>) {\n  const defaultComponents = {\n    formatElapsedTime,\n    getDocumentIndexId,\n    getDocumentProperties,\n    validateSchema\n  }\n\n  for (const rawKey of FUNCTION_COMPONENTS) {\n    const key = rawKey as keyof FunctionComponents<OramaSchema>\n\n    if (components[key]) {\n      if (typeof components[key] !== 'function') {\n        throw createError('COMPONENT_MUST_BE_FUNCTION', key)\n      }\n    } else {\n      // @ts-expect-error TSC is unable to resolve this\n      components[key] = defaultComponents[key]\n    }\n  }\n\n  for (const rawKey of Object.keys(components)) {\n    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {\n      throw createError('UNSUPPORTED_COMPONENT', rawKey)\n    }\n  }\n}\n\nexport async function create<\n  OramaSchema,\n  TIndex = IIndex<Index>,\n  TDocumentStore = IDocumentsStore<DocumentsStore>,\n  TSorter = ISorter<Sorter>\n>({\n  schema,\n  sort,\n  language,\n  components,\n  id,\n  plugins\n}: CreateArguments<OramaSchema, TIndex, TDocumentStore, TSorter>): Promise<\n  Orama<OramaSchema, TIndex, TDocumentStore, TSorter>\n> {\n  if (!components) {\n    components = {}\n  }\n\n  if (!id) {\n    id = await uniqueId()\n  }\n\n  let tokenizer = components.tokenizer\n  let index: TIndex | undefined = components.index\n  let documentsStore: TDocumentStore | undefined = components.documentsStore\n  let sorter: TSorter | undefined = components.sorter\n\n  if (!tokenizer) {\n    // Use the default tokenizer\n    tokenizer = await createTokenizer({ language: language ?? 'english' })\n  } else if (!(tokenizer as Tokenizer).tokenize) {\n    // If there is no tokenizer function, we assume this is a TokenizerConfig\n    tokenizer = await createTokenizer(tokenizer)\n  } else {\n    const customTokenizer = tokenizer as Tokenizer\n    tokenizer = customTokenizer\n  }\n\n  if (components.tokenizer && language) {\n    // Accept language only if a tokenizer is not provided\n    throw createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER')\n  }\n\n  const internalDocumentStore = createInternalDocumentIDStore()\n\n  index ||= (await createIndex()) as TIndex\n  sorter ||= (await createSorter()) as TSorter\n  documentsStore ||= (await createDocumentsStore()) as TDocumentStore\n\n  // Validate all other components\n  validateComponents(components)\n\n  // Assign only recognized components and hooks\n  const { getDocumentProperties, getDocumentIndexId, validateSchema, formatElapsedTime } = components\n\n  const orama = {\n    data: {},\n    caches: {},\n    schema,\n    tokenizer,\n    index,\n    sorter,\n    documentsStore,\n    internalDocumentIDStore: internalDocumentStore,\n    getDocumentProperties,\n    getDocumentIndexId,\n    validateSchema,\n    beforeInsert: [],\n    afterInsert: [],\n    beforeRemove: [],\n    afterRemove: [],\n    beforeUpdate: [],\n    afterUpdate: [],\n    beforeSearch: [],\n    afterSearch: [],\n    beforeInsertMultiple: [],\n    afterInsertMultiple: [],\n    beforeRemoveMultiple: [],\n    afterRemoveMultiple: [],\n    afterUpdateMultiple: [],\n    beforeUpdateMultiple: [],\n    afterCreate: [],\n    formatElapsedTime,\n    id,\n    plugins,\n    version: getVersion()\n  } as unknown as Orama<OramaSchema, TIndex, TDocumentStore, TSorter>\n\n  orama.data = {\n    index: await orama.index.create(orama, internalDocumentStore, schema),\n    docs: await orama.documentsStore.create(orama, internalDocumentStore),\n    sorting: await orama.sorter.create(orama, internalDocumentStore, schema, sort)\n  }\n\n  for (const hook of AVAILABLE_PLUGIN_HOOKS) {\n    orama[hook] = (orama[hook] ?? []).concat(await getAllPluginsByHook(orama, hook))\n  }\n\n  const afterCreate = orama['afterCreate']\n  if (afterCreate) {\n    await runAfterCreate(afterCreate, orama)\n  }\n\n  return orama\n}\n\nfunction getVersion() {\n  return '{{VERSION}}'\n}\n"],"names":["formatElapsedTime","getDocumentIndexId","getDocumentProperties","validateSchema","createDocumentsStore","AVAILABLE_PLUGIN_HOOKS","getAllPluginsByHook","FUNCTION_COMPONENTS","OBJECT_COMPONENTS","runAfterCreate","createIndex","createInternalDocumentIDStore","createSorter","createTokenizer","createError","uniqueId","validateComponents","components","defaultComponents","rawKey","key","Object","keys","includes","create","schema","sort","language","id","plugins","tokenizer","index","documentsStore","sorter","tokenize","customTokenizer","internalDocumentStore","orama","data","caches","internalDocumentIDStore","beforeInsert","afterInsert","beforeRemove","afterRemove","beforeUpdate","afterUpdate","beforeSearch","afterSearch","beforeInsertMultiple","afterInsertMultiple","beforeRemoveMultiple","afterRemoveMultiple","afterUpdateMultiple","beforeUpdateMultiple","afterCreate","version","getVersion","docs","sorting","hook","concat"],"mappings":"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"}},
    {"offset": {"line": 3816, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/types.ts"],"sourcesContent":["import type { InsertOptions } from './methods/insert.js'\nimport { MODE_FULLTEXT_SEARCH, MODE_HYBRID_SEARCH, MODE_VECTOR_SEARCH } from './constants.js'\nimport { DocumentsStore } from './components/documents-store.js'\nimport { Index } from './components/index.js'\nimport { DocumentID, InternalDocumentID, InternalDocumentIDStore } from './components/internal-document-id-store.js'\nimport { Sorter } from './components/sorter.js'\nimport { Language } from './components/tokenizer/languages.js'\nimport { Point } from './trees/bkd.js'\n\nexport { MODE_FULLTEXT_SEARCH, MODE_HYBRID_SEARCH, MODE_VECTOR_SEARCH } from './constants.js'\n\nexport type { DefaultTokenizer } from './components/tokenizer/index.js'\n\nexport type Nullable<T> = T | null\n\nexport type SingleOrArray<T> = T | T[]\n\nexport type SyncOrAsyncValue<T = void> = T | PromiseLike<T>\n\nexport type HybridWeights = {\n  text: number\n  vector: number\n}\n\n// Given a type T, return a new type with:\n// - the concatenation of nested properties as key\n// - the type of the nested property as value\ntype Flatten<T extends object> = object extends T\n  ? object\n  : {\n        [K in keyof T]-?: (\n          // Create a function as argument:\n          // - Pick<T, K> if the value is not an object (not run recursion)\n          // - { [key concatenation]: function calculated by recursion }\n          // - never is the value is an array\n          x: NonNullable<T[K]> extends infer V\n            ? V extends object\n              ? V extends readonly any[]\n                ? never // Orama schema doens't allow array as value\n                : Flatten<V> extends infer FV\n                  ? {\n                      [P in keyof FV as `${Extract<K, string>}.${Extract<P, string>}`]: FV[P]\n                    }\n                  : never // Never happen: it is needed due to `extends` typescript syntax\n              : Pick<T, K>\n            : never // Never happen: it is needed due to typescript syntax\n        ) => void\n      } extends Record<keyof T, (y: infer O) => void>\n    ? O // Return the type of the function argument\n    : never // Never happen: it is needed due to typescript syntax\n\nexport type SchemaTypes<Value> = Value extends 'string'\n  ? string\n  : Value extends 'string[]'\n    ? string[]\n    : Value extends 'boolean'\n      ? boolean\n      : Value extends 'boolean[]'\n        ? boolean[]\n        : Value extends 'number'\n          ? number\n          : Value extends 'number[]'\n            ? number[]\n            : Value extends 'enum'\n              ? string | number\n              : Value extends 'enum[]'\n                ? (string | number)[]\n                : Value extends 'geopoint'\n                  ? Point\n                  : // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    Value extends `vector[${number}]`\n                    ? number[]\n                    : Value extends object\n                      ? { [Key in keyof Value]: SchemaTypes<Value[Key]> } & {\n                          [otherKeys: PropertyKey]: any\n                        }\n                      : never\n\nexport type Schema<TSchema> = TSchema extends AnySchema\n  ? InternalTypedDocument<{\n      -readonly [Key in keyof TSchema]: SchemaTypes<TSchema[Key]>\n    }>\n  : never\n\nexport type AnyDocument = InternalTypedDocument<any>\n\nexport type InternalTypedDocument<TSchema extends object> = { id: DocumentID } & TSchema & {\n    [otherKeys: PropertyKey]: any\n  }\nexport type TypedDocument<T extends AnyOrama> = T['typeSchema']\n\nexport type AnySchema = {\n  [key: PropertyKey]: SearchableType | AnySchema\n}\n\nexport type PartialSchemaDeepObject<T> = T extends object\n  ? {\n      [K in keyof T]?: T[K]\n    }\n  : T\n\nexport type PartialSchemaDeep<T> = {\n  [K in keyof T]?: PartialSchemaDeepObject<T[K]>\n}\n\n/**\n * @deprecated\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface Document extends Record<string, SearchableValue | Document | unknown> {}\n\nexport type Magnitude = number\nexport type Vector = `vector[${number}]`\nexport type VectorType = Float32Array\n\nexport type ScalarSearchableType = 'string' | 'number' | 'boolean' | 'enum' | 'geopoint'\nexport type ArraySearchableType = 'string[]' | 'number[]' | 'boolean[]' | 'enum[]' | Vector\n\nexport type SearchableType = ScalarSearchableType | ArraySearchableType\n\nexport type ScalarSearchableValue = string | number | boolean | Point\nexport type ArraySearchableValue = string[] | number[] | boolean[] | VectorType\nexport type SearchableValue = ScalarSearchableValue | ArraySearchableValue\n\nexport type SortType = 'string' | 'number' | 'boolean'\nexport type SortValue = string | number | boolean\n\nexport type VectorIndex = {\n  size: number\n  vectors: {\n    [docID: string]: [Magnitude, VectorType]\n  }\n}\n\nexport type BM25Params = {\n  k?: number\n  b?: number\n  d?: number\n}\n\nexport type GenericSorting = 'asc' | 'desc' | 'ASC' | 'DESC'\n\nexport type FacetSorting = GenericSorting\n\nexport interface StringFacetDefinition {\n  limit?: number\n  offset?: number\n  sort?: FacetSorting\n}\n\nexport interface NumberFacetDefinition {\n  ranges: { from: number; to: number }[]\n}\n\nexport interface BooleanFacetDefinition {\n  true?: boolean\n  false?: boolean\n}\n\nexport type FacetsParams<T extends AnyOrama> = Partial<Record<LiteralUnion<T['schema']>, FacetDefinition>>\n\nexport type FacetDefinition = StringFacetDefinition | NumberFacetDefinition | BooleanFacetDefinition\n\nexport type ReduceFunction<T, R> = (values: ScalarSearchableValue[], acc: T, value: R, index: number) => T\nexport type Reduce<T, R = AnyDocument> = {\n  reducer: ReduceFunction<T, R>\n  getInitialValue: (elementCount: number) => T\n}\n\nexport type GroupByParams<T extends AnyOrama, ResultDocument> = {\n  properties: LiteralUnion<T['schema']>[]\n  maxResult?: number\n  reduce?: Reduce<ResultDocument>\n}\n\nexport type ComparisonOperator = {\n  gt?: number\n  gte?: number\n  lt?: number\n  lte?: number\n  eq?: number\n  between?: [number, number]\n}\n\nexport type EnumComparisonOperator = {\n  eq?: string | number | boolean\n  in?: (string | number | boolean)[]\n  nin?: (string | number | boolean)[]\n}\n\nexport type EnumArrComparisonOperator = {\n  containsAll?: (string | number | boolean)[]\n}\n\nexport type GeosearchDistanceUnit = 'cm' | 'm' | 'km' | 'ft' | 'yd' | 'mi'\n\nexport type GeosearchRadiusOperator = {\n  radius: {\n    coordinates: Point\n    value: number\n    unit?: GeosearchDistanceUnit\n    inside?: boolean\n    highPrecision?: boolean\n  }\n}\n\nexport type GeosearchPolygonOperator = {\n  polygon: {\n    coordinates: Point[]\n    inside?: boolean\n    highPrecision?: boolean\n  }\n}\n\nexport type GeosearchOperation = GeosearchRadiusOperator | GeosearchPolygonOperator\n\nexport type Operator<Value> = Value extends 'string'\n  ? string | string[]\n  : Value extends 'string[]'\n    ? string | string[]\n    : Value extends 'boolean'\n      ? boolean\n      : Value extends 'boolean[]'\n        ? boolean\n        : Value extends 'number'\n          ? ComparisonOperator\n          : Value extends 'number[]'\n            ? ComparisonOperator\n            : Value extends 'enum'\n              ? EnumComparisonOperator\n              : Value extends 'enum[]'\n                ? EnumArrComparisonOperator\n                : Value extends 'geopoint'\n                  ? GeosearchOperation\n                  : never\nexport type WhereCondition<TSchema> = {\n  [key in keyof TSchema]?: Operator<TSchema[key]>\n}\n\n/**\n * A custom sorter function item as [id, score, document].\n */\nexport type CustomSorterFunctionItem<ResultDocument> = [InternalDocumentID, number, ResultDocument]\n\nexport type CustomSorterFunction<ResultDocument> = (\n  a: CustomSorterFunctionItem<ResultDocument>,\n  b: CustomSorterFunctionItem<ResultDocument>\n) => number\n// thanks to https://github.com/sindresorhus/type-fest/blob/main/source/literal-union.d.ts\nexport type LiteralUnion<T> = (keyof T extends string ? keyof T : never) | (string & Record<never, never>)\n/**\n * Define which properties to sort for.\n */\nexport type SorterParams<T extends AnyOrama> = {\n  /**\n   * The key of the document used to sort the result.\n   */\n  property: LiteralUnion<T['schema']>\n  /**\n   * Whether to sort the result in ascending or descending order.\n   */\n  order?: 'ASC' | 'DESC'\n}\n\nexport type FlattenSchema<T extends AnyOrama> = Flatten<T['schema']>\nexport type FlattenSchemaProperty<T extends AnyOrama> = T['schema'] extends object ? keyof FlattenSchema<T> : string\nexport type OnlyStrings<T extends any[]> = T[number] extends infer V ? (V extends string ? V : never) : never\n\nexport type SortByParams<T extends AnyOrama, ResultDocument> = SorterParams<T> | CustomSorterFunction<ResultDocument>\n\nexport type SearchMode = typeof MODE_FULLTEXT_SEARCH | typeof MODE_HYBRID_SEARCH | typeof MODE_VECTOR_SEARCH\n\n// eslint-disable-next-line\nexport interface SearchParamsBase<T extends AnyOrama, ResultDocument = TypedDocument<T>> {}\n\nexport interface SearchParamsFullText<T extends AnyOrama, ResultDocument = TypedDocument<T>>\n  extends SearchParamsBase<T, ResultDocument> {\n  /**\n   * The term, sentence, or word to search.\n   */\n  term?: string\n\n  /**\n   * Search mode. Tell Orama to perform either a fulltext search, a vector search or a hybrid search.\n   * By default, Orama will perform a full-text search.\n   */\n  mode?: typeof MODE_FULLTEXT_SEARCH\n\n  /**\n   * The properties of the document to search in.\n   */\n  properties?: '*' | FlattenSchemaProperty<T>[]\n\n  /**\n   * The number of matched documents to return.\n   */\n  limit?: number\n\n  /**\n   * The number of matched documents to skip.\n   */\n  offset?: number\n\n  /**\n   * The key of the document used to sort the result.\n   */\n  sortBy?: SortByParams<T, ResultDocument>\n\n  /**\n   * Whether to match the term exactly.\n   */\n  exact?: boolean\n\n  /**\n   * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n   * between the term and the searchable property.\n   */\n  tolerance?: number\n\n  /**\n   * The BM25 parameters to use.\n   *\n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   *\n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   *\n   * d: Frequency normalization lower bound. Default value is 0.5.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/BM25-algorithm\n   *\n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25Params\n\n  /**\n   * The boost to apply to the properties.\n   *\n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/fields-boosting\n   *\n   * @example\n   * // Give more importance to the 'title' property.\n   * const result = await search(db, {\n   *  term: 'Michael',\n   *  properties: ['title', 'author'],\n   *  boost: {\n   *   title: 2\n   *  }\n   * });\n   *\n   * // In that case, the score of the 'title' property will be multiplied by 2.\n   */\n  boost?: Partial<Record<OnlyStrings<FlattenSchemaProperty<T>[]>, number>>\n\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/facets\n   *\n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   *\n   * @example\n   *\n   * const results = await search(db, {\n   *  term: 'Personal Computer',\n   *  properties: ['title', 'description', 'category.primary', 'category.secondary'],\n   *  facets: {\n   *    'category.primary': {\n   *      limit: 10,\n   *      sort: 'ASC',\n   *    }\n   *  }\n   * });\n   */\n  facets?: FacetsParams<T>\n\n  /**\n   * Distinct configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/introduction#distinct\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  distinctOn: 'category.primary',\n   * })\n   */\n  distinctOn?: LiteralUnion<T['schema']>\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/grouping\n   *\n   * @example\n   * const results = await search(db, {\n   *  term: 'Headphones',\n   *  groupBy: {\n   *   properties: ['category.primary'],\n   *   maxResult: 10,\n   *  }\n   * })\n   */\n  groupBy?: GroupByParams<T, ResultDocument>\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/filters\n   *\n   * @example\n   * // Search for documents that contain 'Headphones' in the 'description' and 'title' fields and\n   * // have a price less than 100.\n   *\n   * const result = await search(db, {\n   *  term: 'Headphones',\n   *  properties: ['description', 'title'],\n   *  where: {\n   *    price: {\n   *      lt: 100\n   *    }\n   *  }\n   * });\n   */\n  where?: Partial<WhereCondition<T['schema']>>\n\n  /**\n   * Threshold to use for refining the search results.\n   * The threshold is a number between 0 and 1 that represents the minimum score of the documents to return.\n   * By default, the threshold is 0.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/threshold\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 0\n   * });\n   *\n   * // The result will contain all the documents that contain both 'Red' and 'Headphones' in their properties.\n   *\n   * const result2 = await search(db, {\n   *  term: 'Red Headphones'\n   *  threshold: 1\n   * });\n   *\n   * // The result will contain all the documents that contain either 'Red' and 'Headphones' in their properties.\n   */\n  threshold?: number\n\n  /**\n   * Preflight query.\n   * Will return just the facets (if needed) and the number of matched documents for the given query.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/preflight\n   *\n   * @example\n   *\n   * const result = await search(db, {\n   *  term: 'Red Headphones',\n   *  preflight: true\n   * });\n   *\n   * console.log(result);\n   *\n   * // {\n   * //   elapsed: {\n   * //     raw: 181208,\n   * //     formatted: '181μs'\n   * //   },\n   * //   count: 100,\n   * // }\n   */\n  preflight?: boolean\n\n  /**\n   * Whether to include the vectors in the result.\n   * By default, Orama will not include the vectors, as they can be quite large.\n   * If set to \"false\" (default), vectors will be presented as \"null\".\n   */\n  includeVectors?: boolean\n}\n\nexport interface SearchParamsHybrid<T extends AnyOrama, ResultDocument = TypedDocument<T>>\n  extends SearchParamsBase<T, ResultDocument> {\n  /**\n   * The vector used to perform vector similarity search.\n   * Since \"mode\" is set to \"hybrid\", Orama will perform a full-text search and a vector search,\n   * therefore, you have to provide a \"term\" property as well when setting the \"vector\" property.\n   *\n   * @example\n   * const result = await search(db, {\n   *  term: 'Noise cancelling headphones',\n   *  vector: {\n   *    value: [0.1, 0.2, 0.3],\n   *    property: 'embedding'\n   *  }\n   * })\n   */\n  vector?: {\n    value: Array<number> | VectorType\n    property: string\n  }\n\n  /**\n   * The term, sentence, or word to search.\n   * @example\n   * const result = await search(db, {\n   *   term: 'Noise cancelling headphones',\n   *   mode: 'hybrid',\n   * })\n   */\n  term: string\n\n  /**\n   * Search mode. Tell Orama to perform either a fulltext search, a vector search or a hybrid search.\n   * By default, Orama will perform a full-text search.\n   */\n  mode: typeof MODE_HYBRID_SEARCH\n\n  /**\n   * The properties of the document to search in (for the full-text search part).\n   */\n  properties?: '*' | FlattenSchemaProperty<T>[]\n\n  /**\n   * The BM25 parameters to use.\n   *\n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   *\n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   *\n   * d: Frequency normalization lower bound. Default value is 0.5.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/BM25-algorithm\n   *\n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25Params\n\n  /**\n   * The number of matched documents to return.\n   * By default, Orama will return 10 of each (10 for full-text search, and 10 for vector search).\n   */\n  limit?: number\n\n  /**\n   * The number of matched documents to skip.\n   * By default, Orama will skip 0 of each (0 for full-text search, and 0 for vector search).\n   */\n  offset?: number\n\n  /**\n   * Similarity threshold for the vector search.\n   * By default, Orama will use 0.8.\n   */\n  similarity?: number\n\n  /**\n   * Whether to include the vectors in the result.\n   * By default, Orama will not include the vectors, as they can be quite large.\n   * If set to \"false\" (default), vectors will be presented as \"null\".\n   */\n  includeVectors?: boolean\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/grouping\n   */\n  groupBy?: GroupByParams<T, ResultDocument>\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/filters\n   */\n  where?: Partial<WhereCondition<T['schema']>>\n\n  /**\n   * Threshold to use for refining the search results.\n   * The threshold is a number between 0 and 1 that represents the minimum score of the documents to return.\n   * By default, the threshold is 1. Only applies to the full-text search.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/threshold\n   */\n  threshold?: number\n\n  /**\n   * The boost to apply to the properties.\n   *\n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties. Only applies to the full-text search.\n   *\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/fields-boosting\n   */\n  boost?: Partial<Record<OnlyStrings<FlattenSchemaProperty<T>[]>, number>>\n\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/facets\n   *\n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   */\n  facets?: FacetsParams<T>\n\n  /**\n   * Hybrid search weights.\n   * By default, Orama will use 0.5 for the full-text search and 0.5 for the vector search, which means that both will have the same importance.\n   * You can change the weights to give more importance to the full-text search or the vector search.\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/hybrid-search\n   */\n  hybridWeights?: HybridWeights\n}\n\nexport interface SearchParamsVector<T extends AnyOrama, ResultDocument = TypedDocument<T>>\n  extends SearchParamsBase<T, ResultDocument> {\n  /**\n   * Search mode. Tell Orama to perform either a fulltext search, a vector search or a hybrid search.\n   * By default, Orama will perform a full-text search.\n   */\n  mode: typeof MODE_VECTOR_SEARCH\n\n  /**\n   * The search term. If used with the Orama Secure Proxy, this will be converted into a vector automatically for you.\n   *\n   * @example\n   * import { pluginSecureProxy } from '@orama/plugin-secure-proxy'\n   *\n   * const db = await create({\n   *   schema: {\n   *     title: 'string',\n   *     description: 'string',\n   *     embedding: 'vector[3]',\n   *   },\n   *   plugins: [\n   *     await pluginSecureProxy({ apiKey: '', defaultProperty: 'embedding' })\n   *   ]\n   * });\n   *\n   * const result = await search(db, {\n   *   mode: 'vector',\n   *   term: 'Noise cancelling headphones',\n   * });\n   */\n  term?: string\n\n  /**\n   * The vector used to perform vector similarity search.\n   *\n   * @example\n   * const db = await create({\n   *   schema: {\n   *     embeddings: 'vector[3]'\n   *   }\n   * })\n   *\n   * const result = await search(db, {\n   *   mode: 'vector',\n   *   vector {\n   *     value: [0.1, 0.2, 0.3],\n   *     property: 'embedding',\n   *   }\n   * })\n   */\n  vector?: {\n    value: Array<number> | VectorType\n    property: string\n  }\n\n  /**\n   * The minimum similarity score between the vector and the document.\n   * By default, Orama will use 0.8.\n   */\n  similarity?: number\n\n  /**\n   * Filter the search results.\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/filters\n   */\n  where?: Partial<WhereCondition<T['schema']>>\n\n  /**\n   * Facets configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/facets\n   */\n  facets?: FacetsParams<T>\n\n  /**\n   * Groups configuration\n   * Full documentation: https://docs.oramasearch.com/open-source/usage/search/grouping\n   */\n  groupBy?: GroupByParams<T, ResultDocument>\n\n  /**\n   * The number of matched documents to return.\n   * By default, Orama will return 10.\n   */\n  limit?: number\n\n  /**\n   * The number of matched documents to skip.\n   * By default, Orama will skip 0.\n   */\n  offset?: number\n\n  /**\n   * Whether to include the vectors in the result.\n   * By default, Orama will not include the vectors, as they can be quite large.\n   * If set to \"false\" (default), vectors will be presented as \"null\".\n   */\n  includeVectors?: boolean\n}\n\nexport type SearchParams<T extends AnyOrama, ResultDocument = TypedDocument<T>> =\n  | SearchParamsFullText<T, ResultDocument>\n  | SearchParamsHybrid<T, ResultDocument>\n  | SearchParamsVector<T, ResultDocument>\n\nexport type Result<Document> = {\n  /**\n   * The id of the document.\n   */\n  id: string\n  /**\n   * The score of the document in the search.\n   */\n  score: number\n  /**\n   * The document\n   */\n  document: Document\n}\n\nexport type FacetResult = Record<\n  string,\n  {\n    count: number\n    values: Record<string, number>\n  }\n>\n\nexport type GroupResult<Document> = {\n  values: ScalarSearchableValue[]\n  result: Result<Document>[]\n}[]\n\nexport type TokenScore = [id: InternalDocumentID, score: number]\n\nexport type TokenMap = Record<string, TokenScore[]>\n\nexport type IndexMap = Record<string, TokenMap>\n\nexport type SearchContext<\n  T extends AnyOrama,\n  ResultDocument = TypedDocument<T>,\n  P = SearchParams<T, ResultDocument>\n> = {\n  timeStart: bigint\n  tokenizer: Tokenizer\n  index: T['index']\n  documentsStore: T['documentsStore']\n  language: string | undefined\n  params: P\n  docsCount: number\n  uniqueDocsIDs: Record<number, number>\n  indexMap: IndexMap\n  docsIntersection: TokenMap\n}\n\nexport type ElapsedTime = {\n  raw: number\n  formatted: string\n}\n\nexport interface HybridResultsBase<Document> {\n  /**\n   * The number of all the matched documents, combining vector and full-text search. Will contain duplicated results between vector and full-text search.\n   */\n  count: number\n\n  /**\n   * All the matched elements from the full-text search.\n   */\n  hits: Result<Document>[]\n\n  /**\n   * The time taken to search.\n   */\n  elapsed: ElapsedTime\n\n  /**\n   * The facets results. Includes full-text search facets only.\n   */\n  facets?: FacetResult\n\n  /**\n   * The groups results. Includes full-text search groups only.\n   */\n  groups?: GroupResult<Document>\n}\n\nexport interface HybridResultsCombine<Document> extends HybridResultsBase<Document> {\n  /**\n   * All the matched elements from the vector search.\n   */\n  hitsVector: Result<Document>[]\n}\n\nexport type Results<Document> = {\n  /**\n   * The number of all the matched documents.\n   */\n  count: number\n\n  /**\n   * An array of matched documents taking `limit` and `offset` into account.\n   */\n  hits: Result<Document>[]\n\n  /**\n   * The time taken to search.\n   */\n  elapsed: ElapsedTime\n\n  /**\n   * The facets results.\n   */\n  facets?: FacetResult\n\n  /**\n   * The groups results.\n   */\n  groups?: GroupResult<Document>\n}\n\n/**\n * Sometimes {@link doc} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = doc as MyType;\n * ```\n */\nexport type SingleCallbackComponent<T extends AnyOrama> = (\n  orama: T,\n  id: string,\n  doc?: TypedDocument<T>\n) => SyncOrAsyncValue\n\n/**\n * Sometimes {@link doc} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = doc as MyType;\n * ```\n */\nexport type MultipleCallbackComponent<T extends AnyOrama> = (\n  orama: T,\n  doc: TypedDocument<T>[] | string[]\n) => SyncOrAsyncValue\n\n/**\n * Sometimes {@link results} will not have the correct type; in these cases,\n * you can simply create a new variable and convert it to the correct type like:\n *\n * @example```ts\n * const fixedType = results as Results<MyType>;\n * ```\n */\nexport type AfterSearch<T extends AnyOrama, ResultDocument extends TypedDocument<T> = TypedDocument<T>> = (\n  db: T,\n  params: SearchParams<T, ResultDocument>,\n  language: string | undefined,\n  results: Results<ResultDocument>\n) => SyncOrAsyncValue\n\nexport type BeforeSearch<T extends AnyOrama> = (\n  db: T,\n  params: SearchParams<T>,\n  language: string | undefined\n) => SyncOrAsyncValue\n\nexport type AfterCreate<T extends AnyOrama> = (db: T) => SyncOrAsyncValue\n\nexport type IIndexInsertOrRemoveHookFunction = <R = void>(\n  index: AnyIndexStore,\n  prop: string,\n  id: string,\n  value: SearchableValue,\n  type: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number\n) => SyncOrAsyncValue<R>\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface AnyIndexStore {\n  vectorIndexes: Record<string, VectorIndex>\n}\nexport type AnyIndex = IIndex<AnyIndexStore>\n\nexport interface IIndex<I extends AnyIndexStore> {\n  create<T extends AnyOrama>(\n    orama: T,\n    sharedInternalDocumentStore: T['internalDocumentIDStore'],\n    schema: T['schema']\n  ): SyncOrAsyncValue<I>\n\n  beforeInsert?: IIndexInsertOrRemoveHookFunction\n  insert: <T extends I>(\n    implementation: IIndex<T>,\n    index: T,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number,\n    options?: InsertOptions\n  ) => SyncOrAsyncValue\n  afterInsert?: IIndexInsertOrRemoveHookFunction\n\n  beforeRemove?: IIndexInsertOrRemoveHookFunction\n  remove: <T extends I>(\n    implementation: IIndex<T>,\n    index: T,\n    prop: string,\n    id: DocumentID,\n    value: SearchableValue,\n    schemaType: SearchableType,\n    language: string | undefined,\n    tokenizer: Tokenizer,\n    docsCount: number\n  ) => SyncOrAsyncValue<boolean>\n  afterRemove?: IIndexInsertOrRemoveHookFunction\n\n  insertDocumentScoreParameters(\n    index: I,\n    prop: string,\n    id: DocumentID,\n    tokens: string[],\n    docsCount: number\n  ): SyncOrAsyncValue\n  insertTokenScoreParameters(index: I, prop: string, id: DocumentID, tokens: string[], token: string): SyncOrAsyncValue\n  removeDocumentScoreParameters(index: I, prop: string, id: DocumentID, docsCount: number): SyncOrAsyncValue\n  removeTokenScoreParameters(index: I, prop: string, token: string): SyncOrAsyncValue\n  calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    prop: string,\n    term: string,\n    ids: DocumentID[]\n  ): SyncOrAsyncValue<TokenScore[]>\n\n  search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    prop: string,\n    term: string\n  ): SyncOrAsyncValue<TokenScore[]>\n  searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n    context: SearchContext<T, ResultDocument>,\n    index: I,\n    filters: Partial<WhereCondition<T['schema']>>\n  ): SyncOrAsyncValue<InternalDocumentID[]>\n\n  getSearchableProperties(index: I): SyncOrAsyncValue<string[]>\n  getSearchablePropertiesWithTypes(index: I): SyncOrAsyncValue<Record<string, SearchableType>>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<I>\n  save<R = unknown>(index: I): SyncOrAsyncValue<R>\n}\n\nexport interface AnyDocumentStore {\n  docs: Record<InternalDocumentID, AnyDocument>\n}\n\nexport interface IDocumentsStore<D extends AnyDocumentStore = AnyDocumentStore> {\n  create<T extends AnyOrama>(orama: T, sharedInternalDocumentStore: InternalDocumentIDStore): SyncOrAsyncValue<D>\n  get(store: D, id: DocumentID): SyncOrAsyncValue<AnyDocument | undefined>\n  getMultiple(store: D, ids: DocumentID[]): SyncOrAsyncValue<(AnyDocument | undefined)[]>\n  getAll(store: D): SyncOrAsyncValue<Record<InternalDocumentID, AnyDocument>>\n  store(store: D, id: DocumentID, doc: AnyDocument): SyncOrAsyncValue<boolean>\n  remove(store: D, id: DocumentID): SyncOrAsyncValue<boolean>\n  count(store: D): SyncOrAsyncValue<number>\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<D>\n  save<R = unknown>(store: D): SyncOrAsyncValue<R>\n}\n\nexport interface SorterConfig {\n  enabled?: boolean\n  unsortableProperties?: string[]\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface AnySorterStore {}\nexport type AnySorter = ISorter<AnySorterStore>\n\nexport interface ISorter<So extends AnySorterStore> {\n  create<T extends AnyOrama>(\n    orama: T,\n    sharedInternalDocumentStore: InternalDocumentIDStore,\n    schema: T['schema'],\n    sorterConfig?: SorterConfig\n  ): SyncOrAsyncValue<So>\n  insert: <T extends So>(\n    sorter: T,\n    prop: string,\n    id: DocumentID,\n    value: SortValue,\n    schemaType: SortType,\n    language: string | undefined\n  ) => SyncOrAsyncValue\n  remove: <T extends So>(sorter: T, prop: string, id: DocumentID) => SyncOrAsyncValue\n\n  load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): SyncOrAsyncValue<So>\n  save<R = unknown>(sorter: So): SyncOrAsyncValue<R>\n\n  sortBy<T extends AnyOrama>(\n    sorter: So,\n    docIds: [DocumentID, number][],\n    by: SorterParams<T>\n  ): Promise<[DocumentID, number][]>\n\n  getSortableProperties(sorter: So): SyncOrAsyncValue<string[]>\n  getSortablePropertiesWithTypes(sorter: So): SyncOrAsyncValue<Record<string, SortType>>\n}\n\nexport type Stemmer = (word: string) => string\n\nexport type DefaultTokenizerConfig = {\n  language?: Language\n  stemming?: boolean\n  stemmer?: Stemmer\n  stemmerSkipProperties?: string | string[]\n  tokenizeSkipProperties?: string | string[]\n  stopWords?: boolean | string[] | ((stopWords: string[]) => string[] | Promise<string[]>)\n  allowDuplicates?: boolean\n}\n\nexport interface Tokenizer {\n  language: string\n  normalizationCache: Map<string, string>\n  tokenize: (raw: string, language?: string, prop?: string) => SyncOrAsyncValue<string[]>\n}\n\nexport interface ObjectComponents<I, D, So> {\n  tokenizer: Tokenizer | DefaultTokenizerConfig\n  index: I\n  documentsStore: D\n  sorter: So\n}\n\nexport interface FunctionComponents<S> {\n  validateSchema(doc: AnyDocument, schema: S): SyncOrAsyncValue<string | undefined>\n  getDocumentIndexId(doc: AnyDocument): SyncOrAsyncValue<string>\n  getDocumentProperties(doc: AnyDocument, paths: string[]): SyncOrAsyncValue<Record<string, string | number | boolean>>\n  formatElapsedTime(number: bigint): SyncOrAsyncValue<number | string | object | ElapsedTime>\n}\n\nexport interface SingleOrArrayCallbackComponents<T extends AnyOrama> {\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeInsert: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterInsert: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeRemove: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterRemove: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeUpdate: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterUpdate: SingleOrArray<SingleCallbackComponent<T>>\n  /**\n   * More details {@link BeforeSearch}\n   */\n  beforeSearch: SingleOrArray<BeforeSearch<T>>\n  /**\n   * More details {@link AfterSearch}\n   */\n  afterSearch: SingleOrArray<AfterSearch<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeInsertMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterInsertMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeRemoveMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterRemoveMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeUpdateMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterUpdateMultiple: SingleOrArray<MultipleCallbackComponent<T>>\n  /**\n   * More details {@link AfterCreate}\n   */\n  afterCreate: SingleOrArray<AfterCreate<T>>\n}\n\nexport interface ArrayCallbackComponents<T extends AnyOrama> {\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeInsert: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterInsert: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeRemove: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterRemove: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  beforeUpdate: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link SingleCallbackComponent}\n   */\n  afterUpdate: SingleCallbackComponent<T>[]\n  /**\n   * More details {@link BeforeSearch}\n   */\n  beforeSearch: BeforeSearch<T>[]\n  /**\n   * More details {@link AfterSearch}\n   */\n  afterSearch: AfterSearch<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeInsertMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterInsertMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeRemoveMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterRemoveMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  beforeUpdateMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link MultipleCallbackComponent}\n   */\n  afterUpdateMultiple: MultipleCallbackComponent<T>[]\n  /**\n   * More details {@link AfterCreate}\n   */\n  afterCreate: AfterCreate<T>[]\n}\n\nexport type Components<T extends AnyOrama, TSchema, TIndex, TDocumentStore, TSorter> = Partial<\n  ObjectComponents<TIndex, TDocumentStore, TSorter> & FunctionComponents<TSchema> & SingleOrArrayCallbackComponents<T>\n>\n\nexport const kInsertions = Symbol('orama.insertions')\nexport const kRemovals = Symbol('orama.removals')\n\nexport type PickIfExtends<T, TExtends, TDefault> = T extends TExtends ? T : TDefault\n\ntype Internals<\n  TSchema,\n  TIndex extends AnyIndexStore,\n  TDocumentStore extends AnyDocumentStore,\n  TSorter extends AnySorterStore\n> = {\n  version: string\n  schema: TSchema\n  typeSchema: Schema<TSchema>\n  tokenizer: Tokenizer\n  index: IIndex<TIndex>\n  documentsStore: IDocumentsStore<TDocumentStore>\n  sorter: ISorter<TSorter>\n  data: {\n    index: TIndex\n    docs: TDocumentStore\n    sorting: TSorter\n  }\n  internalDocumentIDStore: InternalDocumentIDStore\n  caches: Record<string, unknown>\n  [kInsertions]: number | undefined\n  [kRemovals]: number | undefined\n}\n\ntype OramaID = {\n  id: string\n}\n\nexport type ExtractSchema<T> = T extends { schema: infer RawSchema } ? Schema<RawSchema> : never\n\nexport type AnyGeneric<T> = T[]\nexport type AnyGenericIndex<T> = T extends IIndex<infer TStore>\n  ? TStore extends AnyIndexStore\n    ? TStore\n    : never\n  : AnyIndexStore\nexport type AnyGenericDocumentStore<T> = T extends IDocumentsStore<infer TStore>\n  ? TStore extends AnyDocumentStore\n    ? TStore\n    : never\n  : AnyDocumentStore\nexport type AnyGenericSorter<T> = T extends ISorter<infer TSorter>\n  ? TSorter extends AnySorterStore\n    ? TSorter\n    : never\n  : AnySorterStore\n\nexport type PickInferGeneric<T, Default> = T extends AnyGeneric<infer Generic>\n  ? Generic extends Default\n    ? Generic\n    : never\n  : never\n\nexport type Orama<\n  TSchema,\n  TIndex = IIndex<Index>,\n  TDocumentStore = IDocumentsStore<DocumentsStore>,\n  TSorter = ISorter<Sorter>\n> = FunctionComponents<TSchema> &\n  Internals<TSchema, AnyGenericIndex<TIndex>, AnyGenericDocumentStore<TDocumentStore>, AnyGenericSorter<TSorter>> &\n  ArrayCallbackComponents<any> &\n  OramaID & { plugins: OramaPlugin[] }\n\nexport type AnyOrama<TSchema = any> = FunctionComponents<TSchema> &\n  Internals<TSchema, AnyIndexStore, AnyDocumentStore, AnySorterStore> &\n  ArrayCallbackComponents<any> &\n  OramaID & { plugins: OramaPlugin[] }\n\nexport type OramaPluginSync = {\n  name: string\n  beforeInsert?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  afterInsert?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  beforeRemove?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  afterRemove?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  beforeUpdate?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  afterUpdate?: <T extends AnyOrama>(orama: T, id: string, doc: AnyDocument) => SyncOrAsyncValue\n  beforeSearch?: <T extends AnyOrama>(\n    orama: T,\n    params: SearchParams<T>,\n    language: string | undefined\n  ) => SyncOrAsyncValue\n  afterSearch?: <T extends AnyOrama>(\n    orama: T,\n    params: SearchParams<T>,\n    language: string | undefined,\n    results: Results<TypedDocument<T>>\n  ) => SyncOrAsyncValue\n  beforeInsertMultiple?: <T extends AnyOrama>(orama: T, docs: AnyDocument[]) => SyncOrAsyncValue\n  afterInsertMultiple?: <T extends AnyOrama>(orama: T, docs: AnyDocument[]) => SyncOrAsyncValue\n  beforeRemoveMultiple?: <T extends AnyOrama>(orama: T, ids: string[]) => SyncOrAsyncValue\n  afterRemoveMultiple?: <T extends AnyOrama>(orama: T, ids: string[]) => SyncOrAsyncValue\n  beforeUpdateMultiple?: <T extends AnyOrama>(orama: T, docs: AnyDocument[]) => SyncOrAsyncValue\n  afterUpdateMultiple?: <T extends AnyOrama>(orama: T, docs: AnyDocument[]) => SyncOrAsyncValue\n  afterCreate?: <T extends AnyOrama>(orama: T) => SyncOrAsyncValue\n}\n\nexport type OramaPluginAsync = Promise<OramaPluginSync>\n\nexport type OramaPlugin = OramaPluginSync | OramaPluginAsync\n"],"names":["MODE_FULLTEXT_SEARCH","MODE_HYBRID_SEARCH","MODE_VECTOR_SEARCH","kInsertions","Symbol","kRemovals"],"mappings":";;;;;;;AAirCO,MAAMG,cAAcC,OAAO,oBAAmB;AAC9C,MAAMC,YAAYD,OAAO,kBAAiB"}},
    {"offset": {"line": 3829, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/sync-blocking-checker.ts"],"sourcesContent":["import { AnyOrama, kInsertions, kRemovals } from '../types.js'\n\n// Web platforms don't have process. React-Native doesn't have process.emitWarning.\nconst warn =\n  globalThis.process?.emitWarning ??\n  function emitWarning(message: string, options: { code: string }) {\n    console.warn(`[WARNING] [${options.code}] ${message}`)\n  }\n\nexport function trackInsertion<T extends AnyOrama>(orama: T): void {\n  if (typeof orama[kInsertions] !== 'number') {\n    queueMicrotask(() => {\n      orama[kInsertions] = undefined\n    })\n\n    orama[kInsertions] = 0\n  }\n\n  if (orama[kInsertions]! > 1000) {\n    warn(\n      \"Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.\",\n      { code: 'ORAMA0001' }\n    )\n\n    orama[kInsertions] = -1\n  } else if (orama[kInsertions] >= 0) {\n    orama[kInsertions]++\n  }\n}\n\nexport function trackRemoval<T extends AnyOrama>(orama: T): void {\n  if (typeof orama[kRemovals] !== 'number') {\n    queueMicrotask(() => {\n      orama[kRemovals] = undefined\n    })\n\n    orama[kRemovals] = 0\n  }\n\n  if (orama[kRemovals]! > 1000) {\n    warn(\n      \"Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.\",\n      { code: 'ORAMA0002' }\n    )\n\n    orama[kRemovals] = -1\n  } else if (orama[kRemovals] >= 0) {\n    orama[kRemovals]++\n  }\n}\n"],"names":["globalThis","kInsertions","kRemovals","warn","process","emitWarning","message","options","console","code","trackInsertion","orama","queueMicrotask","undefined","trackRemoval"],"mappings":";;;;;;AAAA,SAAmBC,WAAW,EAAEC,SAAS,QAAQ,cAAa;IAI5DF;;AAFF,mFAAmF;AACnF,MAAMG,OACJH,CAAAA,CAAAA,sBAAAA,WAAWI,OAAO,MAAA,QAAlBJ,wBAAAA,KAAAA,IAAAA,KAAAA,IAAAA,oBAAoBK,WAAU,KAC9B,SAASA,YAAYC,OAAe,EAAEC,OAAyB,EAAE;IAC/DC,QAAQL,IAAI,CAAC,CAAC,WAAW,EAAEI,QAAQE,IAAI,CAAC,EAAE,EAAEH,QAAQ,CAAC;AACvD;AAEK,SAASI,eAAmCC,KAAQ,EAAQ;IACjE,IAAI,OAAOA,KAAK,CAACV,mLAAAA,CAAY,KAAK,UAAU;QAC1CW,eAAe,IAAM;YACnBD,KAAK,CAACV,mLAAAA,CAAY,GAAGY;QACvB;QAEAF,KAAK,CAACV,mLAAAA,CAAY,GAAG;IACvB,CAAC;IAED,IAAIU,KAAK,CAACV,mLAAAA,CAAY,GAAI,MAAM;QAC9BE,KACE,yMACA;YAAEM,MAAM;QAAY;QAGtBE,KAAK,CAACV,mLAAAA,CAAY,GAAG,CAAC;IACxB,OAAO,IAAIU,KAAK,CAACV,mLAAAA,CAAY,IAAI,GAAG;QAClCU,KAAK,CAACV,mLAAAA,CAAY;IACpB,CAAC;AACH,CAAC;AAEM,SAASa,aAAiCH,KAAQ,EAAQ;IAC/D,IAAI,OAAOA,KAAK,CAACT,iLAAAA,CAAU,KAAK,UAAU;QACxCU,eAAe,IAAM;YACnBD,KAAK,CAACT,iLAAAA,CAAU,GAAGW;QACrB;QAEAF,KAAK,CAACT,iLAAAA,CAAU,GAAG;IACrB,CAAC;IAED,IAAIS,KAAK,CAACT,iLAAAA,CAAU,GAAI,MAAM;QAC5BC,KACE,qMACA;YAAEM,MAAM;QAAY;QAGtBE,KAAK,CAACT,iLAAAA,CAAU,GAAG,CAAC;IACtB,OAAO,IAAIS,KAAK,CAACT,iLAAAA,CAAU,IAAI,GAAG;QAChCS,KAAK,CAACT,iLAAAA,CAAU;IAClB,CAAC;AACH,CAAC"}},
    {"offset": {"line": 3878, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/insert.ts"],"sourcesContent":["import { isArrayType, isGeoPointType, isVectorType } from '../components.js'\nimport { runMultipleHook, runSingleHook } from '../components/hooks.js'\nimport { trackInsertion } from '../components/sync-blocking-checker.js'\nimport { createError } from '../errors.js'\nimport { Point } from '../trees/bkd.js'\nimport { AnyOrama, PartialSchemaDeep, SortValue, TypedDocument } from '../types.js'\n\nexport type InsertOptions = {\n  avlRebalanceThreshold?: number\n}\n\nexport async function insert<T extends AnyOrama>(\n  orama: T,\n  doc: PartialSchemaDeep<TypedDocument<T>>,\n  language?: string,\n  skipHooks?: boolean,\n  options?: InsertOptions\n): Promise<string> {\n  const errorProperty = await orama.validateSchema(doc, orama.schema)\n  if (errorProperty) {\n    throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty)\n  }\n\n  return innerInsert(orama, doc, language, skipHooks, options)\n}\n\nconst ENUM_TYPE = new Set(['enum', 'enum[]'])\nconst STRING_NUMBER_TYPE = new Set(['string', 'number'])\n\nasync function innerInsert<T extends AnyOrama>(\n  orama: T,\n  doc: PartialSchemaDeep<TypedDocument<T>>,\n  language?: string,\n  skipHooks?: boolean,\n  options?: InsertOptions\n): Promise<string> {\n  const { index, docs } = orama.data\n\n  const id = await orama.getDocumentIndexId(doc)\n\n  if (typeof id !== 'string') {\n    throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id)\n  }\n\n  if (!(await orama.documentsStore.store(docs, id, doc))) {\n    throw createError('DOCUMENT_ALREADY_EXISTS', id)\n  }\n\n  const docsCount = await orama.documentsStore.count(docs)\n\n  if (!skipHooks) {\n    await runSingleHook(orama.beforeInsert, orama, id, doc as TypedDocument<T>)\n  }\n\n  const indexableProperties = await orama.index.getSearchableProperties(index)\n  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n  const indexableValues = await orama.getDocumentProperties(doc, indexableProperties)\n\n  for (const [key, value] of Object.entries(indexableValues)) {\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const actualType = typeof value\n    const expectedType = indexablePropertiesWithTypes[key]\n\n    if (\n      isGeoPointType(expectedType) &&\n      typeof value === 'object' &&\n      typeof (value as Point).lon === 'number' &&\n      typeof (value as Point).lat === 'number'\n    ) {\n      continue\n    }\n\n    if (isVectorType(expectedType) && Array.isArray(value)) {\n      // @todo: Validate vector type. It should be of a given length and contain only floats.\n      continue\n    }\n\n    if (isArrayType(expectedType) && Array.isArray(value)) {\n      continue\n    }\n\n    if (ENUM_TYPE.has(expectedType) && STRING_NUMBER_TYPE.has(actualType)) {\n      continue\n    }\n\n    if (actualType !== expectedType) {\n      throw createError('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType)\n    }\n  }\n\n  for (const prop of indexableProperties) {\n    const value = indexableValues[prop]\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const expectedType = indexablePropertiesWithTypes[prop]\n    await orama.index.beforeInsert?.(\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount\n    )\n    await orama.index.insert(\n      orama.index,\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount,\n      options\n    )\n    await orama.index.afterInsert?.(\n      orama.data.index,\n      prop,\n      id,\n      value,\n      expectedType,\n      language,\n      orama.tokenizer,\n      docsCount\n    )\n  }\n\n  const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting)\n  const sortablePropertiesWithTypes = await orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)\n  const sortableValues = await orama.getDocumentProperties(doc, sortableProperties)\n  for (const prop of sortableProperties) {\n    const value = sortableValues[prop] as SortValue\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    const expectedType = sortablePropertiesWithTypes[prop]\n\n    await orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language)\n  }\n\n  if (!skipHooks) {\n    await runSingleHook(orama.afterInsert, orama, id, doc as TypedDocument<T>)\n  }\n\n  trackInsertion(orama)\n\n  return id\n}\n\nexport async function insertMultiple<T extends AnyOrama>(\n  orama: T,\n  docs: PartialSchemaDeep<TypedDocument<T>>[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n  timeout?: number\n): Promise<string[]> {\n  if (!skipHooks) {\n    await runMultipleHook(orama.beforeInsertMultiple, orama, docs as TypedDocument<T>[])\n  }\n\n  // Validate all documents before the insertion\n  const docsLength = docs.length\n  const oramaSchema = orama.schema\n  for (let i = 0; i < docsLength; i++) {\n    const errorProperty = await orama.validateSchema(docs[i], oramaSchema)\n    if (errorProperty) {\n      throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty)\n    }\n  }\n\n  return innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout)\n}\n\nexport async function innerInsertMultiple<T extends AnyOrama>(\n  orama: T,\n  docs: PartialSchemaDeep<TypedDocument<T>>[],\n  batchSize?: number,\n  language?: string,\n  skipHooks?: boolean,\n  timeout?: number\n): Promise<string[]> {\n  if (!batchSize) {\n    batchSize = 1000\n  }\n\n  timeout ??= 0\n\n  const ids: string[] = []\n  await new Promise<void>((resolve, reject) => {\n    let i = 0\n    async function _insertMultiple() {\n      const batch = docs.slice(i * batchSize!, ++i * batchSize!)\n\n      if (!batch.length) {\n        return resolve()\n      }\n\n      for (const doc of batch) {\n        try {\n          const options = { avlRebalanceThreshold: batch.length }\n          const id = await insert(orama, doc, language, skipHooks, options)\n          ids.push(id)\n        } catch (err) {\n          reject(err)\n        }\n      }\n\n      setTimeout(_insertMultiple, timeout)\n    }\n\n    setTimeout(_insertMultiple, timeout)\n  })\n\n  if (!skipHooks) {\n    await runMultipleHook(orama.afterInsertMultiple, orama, docs as TypedDocument<T>[])\n  }\n\n  return ids\n}\n"],"names":["isArrayType","isGeoPointType","isVectorType","runMultipleHook","runSingleHook","trackInsertion","createError","insert","orama","doc","language","skipHooks","options","errorProperty","validateSchema","schema","innerInsert","ENUM_TYPE","Set","STRING_NUMBER_TYPE","index","docs","data","id","getDocumentIndexId","documentsStore","store","docsCount","count","beforeInsert","indexableProperties","getSearchableProperties","indexablePropertiesWithTypes","getSearchablePropertiesWithTypes","indexableValues","getDocumentProperties","key","value","Object","entries","actualType","expectedType","lon","lat","Array","isArray","has","prop","tokenizer","afterInsert","sortableProperties","sorter","getSortableProperties","sorting","sortablePropertiesWithTypes","getSortablePropertiesWithTypes","sortableValues","insertMultiple","batchSize","timeout","beforeInsertMultiple","docsLength","length","oramaSchema","i","innerInsertMultiple","ids","Promise","resolve","reject","_insertMultiple","batch","slice","avlRebalanceThreshold","push","err","setTimeout","afterInsertMultiple"],"mappings":"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"}},
    {"offset": {"line": 4027, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/constants.ts"],"sourcesContent":["export const MODE_FULLTEXT_SEARCH = 'fulltext'\nexport const MODE_HYBRID_SEARCH = 'hybrid'\nexport const MODE_VECTOR_SEARCH = 'vector'\n"],"names":["MODE_FULLTEXT_SEARCH","MODE_HYBRID_SEARCH","MODE_VECTOR_SEARCH"],"mappings":";;;;;;;;AAAO,MAAMA,uBAAuB,WAAU;AACvC,MAAMC,qBAAqB,SAAQ;AACnC,MAAMC,qBAAqB,SAAQ"}},
    {"offset": {"line": 4042, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/facets.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport type {\n  AnyOrama,\n  FacetResult,\n  FacetSorting,\n  FacetsParams,\n  NumberFacetDefinition,\n  SearchableValue,\n  StringFacetDefinition,\n  TokenScore\n} from '../types.js'\nimport { getNested } from '../utils.js'\n\ntype FacetValue = string | boolean | number\n\nfunction sortAsc(a: [string, number], b: [string, number]) {\n  return a[1] - b[1]\n}\n\nfunction sortDesc(a: [string, number], b: [string, number]) {\n  return b[1] - a[1]\n}\n\nfunction sortingPredicateBuilder(order: FacetSorting = 'desc') {\n  return order.toLowerCase() === 'asc' ? sortAsc : sortDesc\n}\n\nexport async function getFacets<T extends AnyOrama>(\n  orama: T,\n  results: TokenScore[],\n  facetsConfig: FacetsParams<T>\n): Promise<FacetResult> {\n  const facets: FacetResult = {}\n  const allIDs = results.map(([id]) => id)\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const facetKeys = Object.keys(facetsConfig!)\n\n  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n\n  for (const facet of facetKeys) {\n    let values\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    // TODO: Revisit this once components land\n    if (properties[facet] === 'number') {\n      const { ranges } = facetsConfig[facet] as NumberFacetDefinition\n      const rangesLength = ranges.length\n      const tmp: [string, number][] = Array.from({ length: rangesLength })\n      for (let i = 0; i < rangesLength; i++) {\n        const range = ranges[i]\n        tmp[i] = [`${range.from}-${range.to}`, 0]\n      }\n      values = Object.fromEntries(tmp)\n    }\n\n    facets[facet] = {\n      count: 0,\n      values: values ?? {}\n    }\n  }\n\n  const allDocsLength = allDocs.length\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i]\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? (await getNested<string>(doc!, facet))!\n        : (doc![facet] as SearchableValue)\n\n      const propertyType = properties[facet]\n      const facetValues = facets[facet].values\n      switch (propertyType) {\n        case 'number': {\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          calculateNumberFacetBuilder(ranges, facetValues)(facetValue as number)\n          break\n        }\n        case 'number[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const ranges = (facetsConfig[facet] as NumberFacetDefinition).ranges\n          const calculateNumberFacet = calculateNumberFacetBuilder(ranges, facetValues, alreadyInsertedValues)\n          for (const v of facetValue as Array<number>) {\n            calculateNumberFacet(v)\n          }\n          break\n        }\n        case 'boolean':\n        case 'enum':\n        case 'string': {\n          calculateBooleanStringOrEnumFacetBuilder(facetValues, propertyType)(facetValue as FacetValue)\n          break\n        }\n        case 'boolean[]':\n        case 'enum[]':\n        case 'string[]': {\n          const alreadyInsertedValues = new Set<string>()\n          const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string'\n          const calculateBooleanStringOrEnumFacet = calculateBooleanStringOrEnumFacetBuilder(\n            facetValues,\n            innerType,\n            alreadyInsertedValues\n          )\n          for (const v of facetValue as Array<FacetValue>) {\n            calculateBooleanStringOrEnumFacet(v)\n          }\n          break\n        }\n        default:\n          throw createError('FACET_NOT_SUPPORTED', propertyType)\n      }\n    }\n  }\n\n  // TODO: We are looping again with the same previous keys, should we creat a single loop instead?\n  for (const facet of facetKeys) {\n    const currentFacet = facets[facet]\n    // Count the number of values for each facet\n    currentFacet.count = Object.keys(currentFacet.values).length\n    // Sort only string-based facets\n    if (properties[facet] === 'string') {\n      const stringFacetDefinition = facetsConfig[facet] as StringFacetDefinition\n      const sortingPredicate = sortingPredicateBuilder(stringFacetDefinition.sort)\n\n      currentFacet.values = Object.fromEntries(\n        Object.entries(currentFacet.values)\n          .sort(sortingPredicate)\n          .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10)\n      )\n    }\n  }\n\n  return facets\n}\n\nfunction calculateNumberFacetBuilder(\n  ranges: NumberFacetDefinition['ranges'],\n  values: Record<string, number>,\n  alreadyInsertedValues?: Set<string>\n) {\n  return (facetValue: number) => {\n    for (const range of ranges) {\n      const value = `${range.from}-${range.to}`\n      if (alreadyInsertedValues?.has(value)) {\n        continue\n      }\n\n      if (facetValue >= range.from && facetValue <= range.to) {\n        if (values[value] === undefined) {\n          values[value] = 1\n        } else {\n          values[value]++\n\n          alreadyInsertedValues?.add(value)\n        }\n      }\n    }\n  }\n}\n\nfunction calculateBooleanStringOrEnumFacetBuilder(\n  values: Record<string, number>,\n  propertyType: 'string' | 'boolean' | 'enum',\n  alreadyInsertedValues?: Set<string>\n) {\n  const defaultValue = propertyType === 'boolean' ? 'false' : ''\n  return (facetValue: FacetValue) => {\n    // String or boolean based facets\n    const value = facetValue?.toString() ?? defaultValue\n    if (alreadyInsertedValues?.has(value)) {\n      return\n    }\n    values[value] = (values[value] ?? 0) + 1\n    alreadyInsertedValues?.add(value)\n  }\n}\n"],"names":["createError","getNested","sortAsc","a","b","sortDesc","sortingPredicateBuilder","order","toLowerCase","getFacets","orama","results","facetsConfig","facets","allIDs","map","id","allDocs","documentsStore","getMultiple","data","docs","facetKeys","Object","keys","properties","index","getSearchablePropertiesWithTypes","facet","values","ranges","rangesLength","length","tmp","Array","from","i","range","to","fromEntries","count","allDocsLength","doc","facetValue","includes","propertyType","facetValues","calculateNumberFacetBuilder","alreadyInsertedValues","Set","calculateNumberFacet","v","calculateBooleanStringOrEnumFacetBuilder","innerType","calculateBooleanStringOrEnumFacet","currentFacet","stringFacetDefinition","sortingPredicate","sort","entries","slice","offset","limit","value","has","undefined","add","defaultValue","toString"],"mappings":"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"}},
    {"offset": {"line": 4185, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/filters.ts"],"sourcesContent":["import { InternalDocumentID } from './internal-document-id-store.js'\n\nexport function intersectFilteredIDs(\n  filtered: InternalDocumentID[],\n  lookedUp: [InternalDocumentID, number][]\n): [InternalDocumentID, number][] {\n  const map = new Map<number, boolean>()\n  const result: [number, number][] = []\n\n  for (const id of filtered) {\n    map.set(id, true)\n  }\n\n  for (const looked of lookedUp) {\n    const [id] = looked\n    if (map.has(id)) {\n      result.push(looked)\n      map.delete(id)\n    }\n  }\n\n  return result\n}\n"],"names":["intersectFilteredIDs","filtered","lookedUp","map","Map","result","id","set","looked","has","push","delete"],"mappings":";;;;AAEO,SAASA,qBACdC,QAA8B,EAC9BC,QAAwC,EACR;IAChC,MAAMC,MAAM,IAAIC;IAChB,MAAMC,SAA6B,EAAE;IAErC,KAAK,MAAMC,MAAML,SAAU;QACzBE,IAAII,GAAG,CAACD,IAAI,IAAI;IAClB;IAEA,KAAK,MAAME,UAAUN,SAAU;QAC7B,MAAM,CAACI,GAAG,GAAGE;QACb,IAAIL,IAAIM,GAAG,CAACH,KAAK;YACfD,OAAOK,IAAI,CAACF;YACZL,IAAIQ,MAAM,CAACL;QACb,CAAC;IACH;IAEA,OAAOD;AACT,CAAC"}},
    {"offset": {"line": 4208, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/components/groups.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { getNested, intersect, safeArrayPush } from '../utils.js'\nimport type {\n  AnyDocument,\n  AnyOrama,\n  GroupByParams,\n  GroupResult,\n  Reduce,\n  Result,\n  ScalarSearchableValue,\n  SearchableType,\n  TokenScore,\n  TypedDocument\n} from '../types.js'\nimport { getDocumentIdFromInternalId } from './internal-document-id-store.js'\nimport { Point } from '../trees/bkd.js'\n\ninterface PropertyGroup {\n  property: string\n  perValue: Record<\n    string,\n    {\n      indexes: number[]\n      count: number\n    }\n  >\n}\n\ninterface Group {\n  values: ScalarSearchableValue[]\n  indexes: number[]\n}\n\ntype GroupableType = Exclude<SearchableType, Point>\n\nconst DEFAULT_REDUCE: Reduce<Result<AnyDocument>[]> = {\n  reducer: (_, acc, res, index) => {\n    acc[index] = res\n    return acc\n  },\n  getInitialValue: (length) => Array.from({ length })\n}\n\nconst ALLOWED_TYPES = ['string', 'number', 'boolean']\n\nexport async function getGroups<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  results: TokenScore[],\n  groupBy: GroupByParams<T, ResultDocument>\n): Promise<GroupResult<ResultDocument>> {\n  const properties = groupBy.properties\n  const propertiesLength = properties.length\n\n  const schemaProperties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index)\n  for (let i = 0; i < propertiesLength; i++) {\n    const property = properties[i]\n    if (typeof schemaProperties[property] === 'undefined') {\n      throw createError('UNKNOWN_GROUP_BY_PROPERTY', property)\n    }\n    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {\n      throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property])\n    }\n  }\n\n  const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id))\n\n  // allDocs is already sorted by the sortBy algorithm\n  // We leverage on that to limit the number of documents returned\n  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs)\n  const allDocsLength = allDocs.length\n\n  const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER\n\n  const listOfValues: ScalarSearchableValue[][] = []\n\n  // We want to understand which documents have which values\n  // and group them by the property and values\n  const g: Record<string, PropertyGroup> = {}\n  for (let i = 0; i < propertiesLength; i++) {\n    const groupByKey = properties[i]\n    const group: PropertyGroup = {\n      property: groupByKey,\n      perValue: {}\n    }\n\n    const values: Set<ScalarSearchableValue> = new Set()\n    for (let j = 0; j < allDocsLength; j++) {\n      const doc = allDocs[j]\n\n      const value = await getNested<ScalarSearchableValue>(doc as object, groupByKey)\n      // we don't want to consider undefined values\n      if (typeof value === 'undefined') {\n        continue\n      }\n      const keyValue = typeof value !== 'boolean' ? value : '' + value\n      const perValue = group.perValue[keyValue as GroupableType] ?? {\n        indexes: [],\n        count: 0\n      }\n      if (perValue.count >= returnedCount) {\n        // We stop early because for this value we react the limit\n        continue\n      }\n\n      // We use the index to keep track of the original order\n      perValue.indexes.push(j)\n      perValue.count++\n\n      group.perValue[keyValue as GroupableType] = perValue\n\n      values.add(value)\n    }\n\n    listOfValues.push(Array.from(values))\n\n    g[groupByKey] = group\n  }\n\n  const combinations = calculateCombination(listOfValues)\n  const combinationsLength = combinations.length\n\n  const groups: Group[] = []\n  for (let i = 0; i < combinationsLength; i++) {\n    const combination = combinations[i]\n    const combinationLength = combination.length\n\n    const group: Group = {\n      values: [],\n      indexes: []\n    }\n    const indexes: number[][] = []\n    for (let j = 0; j < combinationLength; j++) {\n      const value = combination[j]\n      const property = properties[j]\n      indexes.push(g[property].perValue[(typeof value !== 'boolean' ? value : '' + value) as GroupableType].indexes)\n      group.values.push(value)\n    }\n    // We leverage on the index to sort the results by the original order\n    group.indexes = intersect(indexes).sort((a, b) => a - b)\n\n    // don't generate empty groups\n    if (group.indexes.length === 0) {\n      continue\n    }\n\n    groups.push(group)\n  }\n\n  const groupsLength = groups.length\n  const res: GroupResult<ResultDocument> = Array.from({ length: groupsLength })\n  for (let i = 0; i < groupsLength; i++) {\n    const group = groups[i]\n\n    const reduce = (groupBy.reduce || DEFAULT_REDUCE) as Reduce<Result<ResultDocument>[]>\n\n    const docs = group.indexes.map((index) => {\n      return {\n        id: allIDs[index],\n        score: results[index][1],\n        document: allDocs[index]!\n      }\n    })\n\n    const func = reduce.reducer.bind(null, group.values)\n    const initialValue = reduce.getInitialValue(group.indexes.length)\n    const aggregationValue = docs.reduce(func, initialValue)\n\n    res[i] = {\n      values: group.values,\n      result: aggregationValue\n    }\n  }\n\n  return res\n}\n\nfunction calculateCombination(arrs: ScalarSearchableValue[][], index = 0): ScalarSearchableValue[][] {\n  if (index + 1 === arrs.length) return arrs[index].map((item) => [item])\n\n  const head = arrs[index]\n  const c = calculateCombination(arrs, index + 1)\n\n  const combinations: ScalarSearchableValue[][] = []\n  for (const value of head) {\n    for (const combination of c) {\n      const result = [value]\n\n      safeArrayPush(result, combination)\n\n      combinations.push(result)\n    }\n  }\n\n  return combinations\n}\n"],"names":["createError","getNested","intersect","safeArrayPush","getDocumentIdFromInternalId","DEFAULT_REDUCE","reducer","_","acc","res","index","getInitialValue","length","Array","from","ALLOWED_TYPES","getGroups","orama","results","groupBy","properties","propertiesLength","schemaProperties","getSearchablePropertiesWithTypes","data","i","property","includes","join","allIDs","map","id","internalDocumentIDStore","allDocs","documentsStore","getMultiple","docs","allDocsLength","returnedCount","maxResult","Number","MAX_SAFE_INTEGER","listOfValues","g","groupByKey","group","perValue","values","Set","j","doc","value","keyValue","indexes","count","push","add","combinations","calculateCombination","combinationsLength","groups","combination","combinationLength","sort","a","b","groupsLength","reduce","score","document","func","bind","initialValue","aggregationValue","result","arrs","item","head","c"],"mappings":"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"}},
    {"offset": {"line": 4357, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/search-fulltext.ts"],"sourcesContent":["import { prioritizeTokenScores } from '../components/algorithms.js'\nimport { getFacets } from '../components/facets.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { getGroups } from '../components/groups.js'\nimport { runAfterSearch, runBeforeSearch } from '../components/hooks.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getInternalDocumentId } from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport type {\n  AnyOrama,\n  CustomSorterFunctionItem,\n  ElapsedTime,\n  Results,\n  SearchParamsFullText,\n  TokenScore,\n  TypedDocument\n} from '../types.js'\nimport { getNanosecondsTime, removeVectorsFromHits, safeArrayPush, sortTokenScorePredicate } from '../utils.js'\nimport { createSearchContext, defaultBM25Params, fetchDocuments, fetchDocumentsWithDistinct } from './search.js'\n\nexport async function fullTextSearch<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParamsFullText<T, ResultDocument>,\n  language?: string\n): Promise<Results<ResultDocument>> {\n  const timeStart = await getNanosecondsTime()\n\n  if (orama.beforeSearch) {\n    await runBeforeSearch(orama.beforeSearch, orama, params, language)\n  }\n\n  params.relevance = Object.assign(defaultBM25Params, params.relevance ?? {})\n\n  const vectorProperties = Object.keys(orama.data.index.vectorIndexes)\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const { limit = 10, offset = 0, term, properties, threshold = 0, distinctOn, includeVectors = false } = params\n  const isPreflight = params.preflight === true\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term ?? '', language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string')\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    for (const prop of properties) {\n      if (!propertiesToSearch.includes(prop as string)) {\n        throw createError('UNKNOWN_INDEX', prop as string, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => (properties as string[]).includes(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n    timeStart\n  )\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: InternalDocumentID[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n  }\n\n  const tokensLength = tokens.length\n\n  if (tokensLength || properties?.length) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n      const docIds = context.indexMap[prop]\n\n      if (tokensLength !== 0) {\n        for (let j = 0; j < tokensLength; j++) {\n          const term = tokens[j]\n\n          // Lookup\n          const scoreList = await orama.index.search(context, index, prop, term)\n\n          safeArrayPush(docIds[term], scoreList)\n        }\n      } else {\n        docIds[''] = []\n        const scoreList = await orama.index.search(context, index, prop, '')\n        safeArrayPush(docIds[''], scoreList)\n      }\n\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold, tokensLength)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n        const prevScore = context.uniqueDocsIDs[id]\n        if (prevScore) {\n          context.uniqueDocsIDs[id] = prevScore + score + 0.5\n        } else {\n          context.uniqueDocsIDs[id] = score\n        }\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k) => [k, 0])\n    )\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map\n  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).map(([id, score]) => [+id, score] as TokenScore)\n\n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray)\n  }\n\n  if (params.sortBy) {\n    if (typeof params.sortBy === 'function') {\n      const ids = uniqueDocsArray.map(([id]) => id)\n      const docs = await orama.documentsStore.getMultiple(orama.data.docs, ids)\n      const docsWithIdAndScore: CustomSorterFunctionItem<ResultDocument>[] = docs.map((d, i) => [\n        uniqueDocsArray[i][0],\n        uniqueDocsArray[i][1],\n        d!\n      ])\n      docsWithIdAndScore.sort(params.sortBy)\n      uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score])\n    } else {\n      uniqueDocsArray = await orama.sorter\n        .sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)\n        .then((results) =>\n          results.map(([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score])\n        )\n    }\n  } else {\n    uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate)\n  }\n\n  let results\n  if (!isPreflight) {\n    results = await (distinctOn\n      ? fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)\n      : fetchDocuments(orama, uniqueDocsArray, offset, limit))\n  }\n\n  const searchResult: Results<ResultDocument> = {\n    elapsed: {\n      formatted: '',\n      raw: 0\n    },\n    // We keep the hits array empty if it's a preflight request.\n    hits: [],\n    count: uniqueDocsArray.length\n  }\n\n  if (typeof results !== 'undefined') {\n    searchResult.hits = results.filter(Boolean)\n\n    // Vectors can be very large, so we remove them from the result if not needed\n    if (!includeVectors) {\n      removeVectorsFromHits(searchResult, vectorProperties)\n    }\n  }\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, uniqueDocsArray, params.facets!)\n    searchResult.facets = facets\n  }\n\n  if (params.groupBy) {\n    searchResult.groups = await getGroups<T, ResultDocument>(orama, uniqueDocsArray, params.groupBy)\n  }\n\n  if (orama.afterSearch) {\n    await runAfterSearch(orama.afterSearch, orama, params, language, searchResult)\n  }\n\n  // Calculate elapsed time only at the end of the function\n  searchResult.elapsed = (await orama.formatElapsedTime(\n    (await getNanosecondsTime()) - context.timeStart\n  )) as ElapsedTime\n\n  return searchResult\n}\n"],"names":["prioritizeTokenScores","getFacets","intersectFilteredIDs","getGroups","runAfterSearch","runBeforeSearch","getInternalDocumentId","createError","getNanosecondsTime","removeVectorsFromHits","safeArrayPush","sortTokenScorePredicate","createSearchContext","defaultBM25Params","fetchDocuments","fetchDocumentsWithDistinct","fullTextSearch","orama","params","language","timeStart","beforeSearch","relevance","Object","assign","vectorProperties","keys","data","index","vectorIndexes","shouldCalculateFacets","facets","length","limit","offset","term","properties","threshold","distinctOn","includeVectors","isPreflight","preflight","docs","tokens","tokenizer","tokenize","propertiesToSearch","caches","propertiesToSearchWithTypes","getSearchablePropertiesWithTypes","getSearchableProperties","filter","prop","startsWith","includes","join","context","documentsStore","count","hasFilters","where","whereFiltersIDs","searchByWhereClause","tokensLength","indexesLength","i","docIds","indexMap","j","scoreList","search","vals","values","docsIntersection","boost","uniqueDocs","uniqueDocsLength","id","score","prevScore","uniqueDocsIDs","fromEntries","getAll","map","k","uniqueDocsArray","entries","sortBy","ids","getMultiple","docsWithIdAndScore","d","sort","sorter","sorting","then","results","internalDocumentIDStore","searchResult","elapsed","formatted","raw","hits","Boolean","groupBy","groups","afterSearch","formatElapsedTime"],"mappings":"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"}},
    {"offset": {"line": 4531, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/search-vector.ts"],"sourcesContent":["import type { AnyOrama, Results, SearchParamsVector, TypedDocument, Result } from '../types.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { createSearchContext } from './search.js'\nimport { getNanosecondsTime, formatNanoseconds } from '../utils.js'\nimport { getFacets } from '../components/facets.js'\nimport { createError } from '../errors.js'\nimport { findSimilarVectors } from '../components/cosine-similarity.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { getGroups } from '../components/groups.js'\nimport { getInternalDocumentId, getDocumentIdFromInternalId } from '../components/internal-document-id-store.js'\nimport { Language } from '../index.js'\nimport { runBeforeSearch, runAfterSearch } from '../components/hooks.js'\n\nexport async function searchVector<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParamsVector<T, ResultDocument>,\n  language: Language = 'english'\n): Promise<Results<ResultDocument>> {\n  const timeStart = await getNanosecondsTime()\n\n  if (orama.beforeSearch) {\n    await runBeforeSearch(orama.beforeSearch, orama, params, language)\n  }\n\n  const { vector } = params\n\n  if (vector && (!('value' in vector) || !('property' in vector))) {\n    throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '))\n  }\n\n  const { limit = 10, offset = 0, includeVectors = false } = params\n  const vectorIndex = orama.data.index.vectorIndexes[vector!.property]\n  const vectorSize = vectorIndex.size\n  const vectors = vectorIndex.vectors\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  const { index, docs: oramaDocs } = orama.data\n\n  if (vector?.value.length !== vectorSize) {\n    // eslint-disable-next-line\n    throw createError('INVALID_INPUT_VECTOR', vector?.property!, vectorSize, vector?.value.length!)\n  }\n\n  if (!(vector instanceof Float32Array)) {\n    vector.value = new Float32Array(vector.value)\n  }\n\n  let results = findSimilarVectors(vector.value as Float32Array, vectors, vectorSize, params.similarity).map(\n    ([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]\n  ) as [number, number][]\n\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string')\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  const tokens = []\n\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(oramaDocs),\n    timeStart\n  )\n\n  let whereFiltersIDs: InternalDocumentID[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n    results = intersectFilteredIDs(whereFiltersIDs, results)\n  }\n\n  let facetsResults: any = []\n\n  if (shouldCalculateFacets) {\n    // Populate facets if needed\n    const facets = await getFacets(orama, results, params.facets!)\n    facetsResults = facets\n  }\n\n  const docs: Result<ResultDocument>[] = Array.from({ length: limit })\n\n  for (let i = 0; i < limit; i++) {\n    const result = results[i + offset]\n    if (!result) {\n      break\n    }\n\n    const doc = orama.data.docs.docs[result[0]]\n\n    if (doc) {\n      if (!includeVectors) {\n        doc[vector.property] = null\n      }\n\n      const newDoc: Result<ResultDocument> = {\n        id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, result[0]),\n        score: result[1],\n        document: doc\n      }\n      docs[i] = newDoc\n    }\n  }\n\n  let groups: any = []\n\n  if (params.groupBy) {\n    groups = await getGroups<T, ResultDocument>(orama, results, params.groupBy)\n  }\n\n  if (orama.afterSearch) {\n    await runAfterSearch(orama.afterSearch, orama, params, language, results as any)\n  }\n\n  const timeEnd = await getNanosecondsTime()\n  const elapsedTime = timeEnd - timeStart\n\n  return {\n    count: results.length,\n    hits: docs.filter(Boolean),\n    elapsed: {\n      raw: Number(elapsedTime),\n      formatted: await formatNanoseconds(elapsedTime)\n    },\n    ...(facetsResults ? { facets: facetsResults } : {}),\n    ...(groups ? { groups } : {})\n  }\n}\n"],"names":["createSearchContext","getNanosecondsTime","formatNanoseconds","getFacets","createError","findSimilarVectors","intersectFilteredIDs","getGroups","getInternalDocumentId","getDocumentIdFromInternalId","runBeforeSearch","runAfterSearch","searchVector","orama","params","language","timeStart","beforeSearch","vector","Object","keys","join","limit","offset","includeVectors","vectorIndex","data","index","vectorIndexes","property","vectorSize","size","vectors","shouldCalculateFacets","facets","length","hasFilters","where","docs","oramaDocs","value","Float32Array","results","similarity","map","id","score","internalDocumentIDStore","propertiesToSearch","caches","propertiesToSearchWithTypes","getSearchablePropertiesWithTypes","getSearchableProperties","filter","prop","startsWith","tokens","context","tokenizer","documentsStore","count","whereFiltersIDs","searchByWhereClause","facetsResults","Array","from","i","result","doc","newDoc","document","groups","groupBy","afterSearch","timeEnd","elapsedTime","hits","Boolean","elapsed","raw","Number","formatted"],"mappings":"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"}},
    {"offset": {"line": 4649, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/search-hybrid.ts"],"sourcesContent":["import type {\n  AnyOrama,\n  TypedDocument,\n  SearchParamsHybrid,\n  Results,\n  TokenScore,\n  Result,\n  HybridWeights\n} from '../types.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\nimport { getNanosecondsTime, safeArrayPush, formatNanoseconds, removeVectorsFromHits } from '../utils.js'\nimport { intersectFilteredIDs } from '../components/filters.js'\nimport { prioritizeTokenScores } from '../components/algorithms.js'\nimport { createError } from '../errors.js'\nimport { createSearchContext, defaultBM25Params } from './search.js'\nimport { getFacets } from '../components/facets.js'\nimport { getGroups } from '../components/groups.js'\nimport { findSimilarVectors } from '../components/cosine-similarity.js'\nimport { getInternalDocumentId } from '../components/internal-document-id-store.js'\nimport { fetchDocuments } from './search.js'\nimport { runBeforeSearch, runAfterSearch } from '../components/hooks.js'\n\nexport async function hybridSearch<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParamsHybrid<T, ResultDocument>,\n  language?: string\n): Promise<Results<ResultDocument>> {\n  const timeStart = await getNanosecondsTime()\n\n  if (orama.beforeSearch) {\n    await runBeforeSearch(orama.beforeSearch, orama, params, language)\n  }\n\n  const { offset = 0, limit = 10, includeVectors = false } = params\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0\n\n  const [fullTextIDs, vectorIDs] = await Promise.all([\n    getFullTextSearchIDs(orama, params, language),\n    getVectorSearchIDs(orama, params)\n  ])\n\n  const { index, docs } = orama.data\n  const hybridWeights = params.hybridWeights\n  let uniqueTokenScores = mergeAndRankResults(fullTextIDs, vectorIDs, params.term ?? '', hybridWeights)\n\n  // @todo avoid tokenize twice\n  const tokens = await orama.tokenizer.tokenize(params.term ?? '', language)\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string')\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (params.properties && params.properties !== '*') {\n    for (const prop of params.properties) {\n      if (!propertiesToSearch.includes(prop as string)) {\n        throw createError('UNKNOWN_INDEX', prop as string, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => (params.properties as string[]).includes(prop))\n  }\n\n  // @todo avoid create context twice\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n    timeStart\n  )\n\n  const hasFilters = Object.keys(params.where ?? {}).length > 0\n  let whereFiltersIDs: InternalDocumentID[] = []\n\n  if (hasFilters) {\n    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where!)\n    uniqueTokenScores = intersectFilteredIDs(whereFiltersIDs, uniqueTokenScores)\n  }\n\n  let facetsResults: any\n  if (shouldCalculateFacets) {\n    const facets = await getFacets(orama, uniqueTokenScores, params.facets!)\n    facetsResults = facets\n  }\n\n  let groups: any\n  if (params.groupBy) {\n    groups = await getGroups<T, ResultDocument>(orama, uniqueTokenScores, params.groupBy)\n  }\n\n  const results = (await fetchDocuments(orama, uniqueTokenScores, offset, limit)).filter(Boolean)\n\n  if (orama.afterSearch) {\n    await runAfterSearch(orama.afterSearch, orama, params, language, results as any)\n  }\n\n  const timeEnd = await getNanosecondsTime()\n\n  const returningResults = {\n    count: uniqueTokenScores.length,\n    elapsed: {\n      raw: Number(timeEnd - timeStart),\n      formatted: await formatNanoseconds(timeEnd - timeStart)\n    },\n    hits: results as Result<ResultDocument>[],\n    ...(facetsResults ? { facets: facetsResults } : {}),\n    ...(groups ? { groups } : {})\n  }\n\n  if (!includeVectors) {\n    const vectorProperties = Object.keys(orama.data.index.vectorIndexes)\n    removeVectorsFromHits(returningResults, vectorProperties)\n  }\n\n  return returningResults\n}\n\nasync function getFullTextSearchIDs<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParamsHybrid<T, ResultDocument>,\n  language?: string\n): Promise<TokenScore[]> {\n  const timeStart = await getNanosecondsTime()\n  params.relevance = Object.assign(defaultBM25Params, params.relevance ?? {})\n\n  const { term = '', properties, threshold = 0 } = params\n\n  const { index, docs } = orama.data\n  const tokens = await orama.tokenizer.tokenize(term, language)\n\n  // Get searchable string properties\n  let propertiesToSearch = orama.caches['propertiesToSearch'] as string[]\n  if (!propertiesToSearch) {\n    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index)\n\n    propertiesToSearch = await orama.index.getSearchableProperties(index)\n    propertiesToSearch = propertiesToSearch.filter((prop: string) =>\n      propertiesToSearchWithTypes[prop].startsWith('string')\n    )\n\n    orama.caches['propertiesToSearch'] = propertiesToSearch\n  }\n\n  if (properties && properties !== '*') {\n    const propertiesToSearchSet = new Set(propertiesToSearch)\n    const propertiesSet = new Set(properties as string[])\n\n    for (const prop of properties) {\n      if (!propertiesToSearchSet.has(prop as string)) {\n        throw createError('UNKNOWN_INDEX', prop as string, propertiesToSearch.join(', '))\n      }\n    }\n\n    propertiesToSearch = propertiesToSearch.filter((prop: string) => propertiesSet.has(prop))\n  }\n\n  // Create the search context and the results\n  const context = await createSearchContext(\n    orama.tokenizer,\n    orama.index,\n    orama.documentsStore,\n    language,\n    params,\n    propertiesToSearch,\n    tokens,\n    await orama.documentsStore.count(docs),\n    timeStart\n  )\n\n  const tokensLength = tokens.length\n\n  if (tokensLength || (properties && properties.length > 0)) {\n    // Now it's time to loop over all the indices and get the documents IDs for every single term\n    const indexesLength = propertiesToSearch.length\n    for (let i = 0; i < indexesLength; i++) {\n      const prop = propertiesToSearch[i]\n\n      if (tokensLength !== 0) {\n        for (let j = 0; j < tokensLength; j++) {\n          const term = tokens[j]\n\n          // Lookup\n          const scoreList = await orama.index.search(context, index, prop, term)\n\n          safeArrayPush(context.indexMap[prop][term], scoreList)\n        }\n      } else {\n        const indexMapContent = []\n        context.indexMap[prop][''] = indexMapContent\n        const scoreList = await orama.index.search(context, index, prop, '')\n        safeArrayPush(indexMapContent, scoreList)\n      }\n\n      const docIds = context.indexMap[prop]\n      const vals = Object.values(docIds)\n      context.docsIntersection[prop] = prioritizeTokenScores(vals, params?.boost?.[prop] ?? 1, threshold, tokensLength)\n      const uniqueDocs = context.docsIntersection[prop]\n\n      const uniqueDocsLength = uniqueDocs.length\n      for (let i = 0; i < uniqueDocsLength; i++) {\n        const [id, score] = uniqueDocs[i]\n        const prevScore = context.uniqueDocsIDs[id]\n        context.uniqueDocsIDs[id] = prevScore ? prevScore + score + 0.5 : score\n      }\n    }\n  } else if (tokens.length === 0 && term) {\n    // This case is hard to handle correctly.\n    // For the time being, if tokenizer returns empty array but the term is not empty,\n    // we returns an empty result set\n    context.uniqueDocsIDs = {}\n  } else {\n    context.uniqueDocsIDs = Object.fromEntries(\n      Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k) => [k, 0])\n    )\n  }\n\n  const uniqueIDs = Object.entries(context.uniqueDocsIDs)\n    .map(([id, score]) => [+id, score] as TokenScore)\n    .sort((a, b) => b[1] - a[1])\n\n  return minMaxScoreNormalization(uniqueIDs)\n}\n\nexport async function getVectorSearchIDs<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParamsHybrid<T, ResultDocument>\n): Promise<TokenScore[]> {\n  const vector = params.vector\n  // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n  const vectorIndex = orama.data.index.vectorIndexes[vector?.property!]\n  const vectorSize = vectorIndex.size\n  const vectors = vectorIndex.vectors\n\n  if (vector && (!vector.value || !vector.property)) {\n    throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '))\n  }\n\n  if (vector!.value.length !== vectorSize) {\n    throw createError('INVALID_INPUT_VECTOR', vector!.property, vectorSize, vector!.value.length)\n  }\n\n  if (!(vector instanceof Float32Array)) {\n    vector!.value = new Float32Array(vector!.value)\n  }\n\n  const uniqueIDs = findSimilarVectors(vector!.value as Float32Array, vectors, vectorSize, params.similarity).map(\n    ([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]\n  ) as TokenScore[]\n\n  return minMaxScoreNormalization(uniqueIDs)\n}\n\nfunction extractScore([, score]: TokenScore) {\n  return score\n}\n\nfunction minMaxScoreNormalization(results: TokenScore[]): TokenScore[] {\n  // In this case I disabled the `prefer-spread` rule because spread seems to be slower\n  // eslint-disable-next-line prefer-spread\n  const maxScore = Math.max.apply(Math, results.map(extractScore))\n  return results.map(([id, score]) => [id, score / maxScore] as TokenScore)\n}\n\nfunction normalizeScore(score: number, maxScore: number) {\n  return score / maxScore\n}\n\nfunction hybridScoreBuilder(textWeight: number, vectorWeight: number) {\n  return (textScore: number, vectorScore: number) => textScore * textWeight + vectorScore * vectorWeight\n}\n\nfunction mergeAndRankResults(\n  textResults: TokenScore[],\n  vectorResults: TokenScore[],\n  query: string,\n  hybridWeights: HybridWeights | undefined\n) {\n  // eslint-disable-next-line prefer-spread\n  const maxTextScore = Math.max.apply(Math, textResults.map(extractScore))\n  // eslint-disable-next-line prefer-spread\n  const maxVectorScore = Math.max.apply(Math, vectorResults.map(extractScore))\n  const hasHybridWeights = hybridWeights && hybridWeights.text && hybridWeights.vector\n\n  const { text: textWeight, vector: vectorWeight } = hasHybridWeights ? hybridWeights : getQueryWeights(query)\n  const mergedResults = new Map()\n\n  const textResultsLength = textResults.length\n  const hybridScore = hybridScoreBuilder(textWeight, vectorWeight)\n  for (let i = 0; i < textResultsLength; i++) {\n    const [id, score] = textResults[i]\n    const normalizedScore = normalizeScore(score, maxTextScore)\n    const hybridScoreValue = hybridScore(normalizedScore, 0)\n    mergedResults.set(id, hybridScoreValue)\n  }\n\n  const vectorResultsLength = vectorResults.length\n  for (let i = 0; i < vectorResultsLength; i++) {\n    const [resultId, score] = vectorResults[i]\n    const normalizedScore = normalizeScore(score, maxVectorScore)\n    const existingRes = mergedResults.get(resultId) ?? 0\n    mergedResults.set(resultId, existingRes + hybridScore(0, normalizedScore))\n  }\n\n  return [...mergedResults].sort((a, b) => b[1] - a[1])\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction getQueryWeights(query: string): HybridWeights {\n  // In the next versions of Orama, we will ship a plugin containing a ML model to adjust the weights\n  // based on whether the query is keyword-focused, conceptual, etc.\n  // For now, we just return a fixed value.\n  return {\n    text: 0.5,\n    vector: 0.5\n  }\n}\n"],"names":["getNanosecondsTime","safeArrayPush","formatNanoseconds","removeVectorsFromHits","intersectFilteredIDs","prioritizeTokenScores","createError","createSearchContext","defaultBM25Params","getFacets","getGroups","findSimilarVectors","getInternalDocumentId","fetchDocuments","runBeforeSearch","runAfterSearch","hybridSearch","orama","params","language","timeStart","beforeSearch","offset","limit","includeVectors","shouldCalculateFacets","facets","Object","keys","length","fullTextIDs","vectorIDs","Promise","all","getFullTextSearchIDs","getVectorSearchIDs","index","docs","data","hybridWeights","uniqueTokenScores","mergeAndRankResults","term","tokens","tokenizer","tokenize","propertiesToSearch","caches","propertiesToSearchWithTypes","getSearchablePropertiesWithTypes","getSearchableProperties","filter","prop","startsWith","properties","includes","join","context","documentsStore","count","hasFilters","where","whereFiltersIDs","searchByWhereClause","facetsResults","groups","groupBy","results","Boolean","afterSearch","timeEnd","returningResults","elapsed","raw","Number","formatted","hits","vectorProperties","vectorIndexes","relevance","assign","threshold","propertiesToSearchSet","Set","propertiesSet","has","tokensLength","indexesLength","i","j","scoreList","search","indexMap","indexMapContent","docIds","vals","values","docsIntersection","boost","uniqueDocs","uniqueDocsLength","id","score","prevScore","uniqueDocsIDs","fromEntries","getAll","map","k","uniqueIDs","entries","sort","a","b","minMaxScoreNormalization","vector","vectorIndex","property","vectorSize","size","vectors","value","Float32Array","similarity","internalDocumentIDStore","extractScore","maxScore","Math","max","apply","normalizeScore","hybridScoreBuilder","textWeight","vectorWeight","textScore","vectorScore","textResults","vectorResults","query","maxTextScore","maxVectorScore","hasHybridWeights","text","getQueryWeights","mergedResults","Map","textResultsLength","hybridScore","normalizedScore","hybridScoreValue","set","vectorResultsLength","resultId","existingRes","get"],"mappings":"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"}},
    {"offset": {"line": 4903, "column": 0}, "map": {"version":3,"sources":["file:///Users/itaiharpaz/Code/ThoughtsManager/node_modules/%40orama/orama/src/methods/search.ts"],"sourcesContent":["import { InternalDocumentID, getDocumentIdFromInternalId } from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport { getNested } from '../utils.js'\nimport type {\n  AnyOrama,\n  BM25Params,\n  IndexMap,\n  LiteralUnion,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  SearchParamsFullText,\n  SearchParamsHybrid,\n  SearchParamsVector,\n  SearchableValue,\n  TokenMap,\n  Tokenizer,\n  TypedDocument\n} from '../types.js'\nimport { MODE_FULLTEXT_SEARCH, MODE_HYBRID_SEARCH, MODE_VECTOR_SEARCH } from '../constants.js'\nimport { fullTextSearch } from './search-fulltext.js'\nimport { searchVector } from './search-vector.js'\nimport { hybridSearch } from './search-hybrid.js'\n\nexport const defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5\n}\n\nexport async function createSearchContext<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  tokenizer: Tokenizer,\n  index: T['index'],\n  documentsStore: T['documentsStore'],\n  language: string | undefined,\n  params: SearchParams<T, ResultDocument>,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n  timeStart: bigint\n): Promise<SearchContext<T, ResultDocument>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart,\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection\n  }\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParams<T, ResultDocument>,\n  language?: string\n): Promise<Results<ResultDocument>> {\n  const mode = params.mode ?? MODE_FULLTEXT_SEARCH\n\n  if (mode === MODE_FULLTEXT_SEARCH) {\n    return fullTextSearch(orama, params as SearchParamsFullText<T, ResultDocument>, language)\n  }\n\n  if (mode === MODE_VECTOR_SEARCH) {\n    return searchVector(orama, params as SearchParamsVector<T, ResultDocument>)\n  }\n\n  if (mode === MODE_HYBRID_SEARCH) {\n    return hybridSearch(orama, params as SearchParamsHybrid<T, ResultDocument>)\n  }\n\n  throw createError('INVALID_SEARCH_MODE', mode)\n}\n\nexport async function fetchDocumentsWithDistinct<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n  distinctOn: LiteralUnion<T['schema']>\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  // Keep track which values we already seen\n  const values = new Map<SearchableValue, true>()\n\n  // We cannot know how many results we will have in the end,\n  // so we need cannot pre-allocate the array.\n  const results: Result<ResultDocument>[] = []\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n  const uniqueDocsArrayLength = uniqueDocsArray.length\n  let count = 0\n  for (let i = 0; i < uniqueDocsArrayLength; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      continue\n    }\n\n    const [id, score] = idAndScore\n\n    if (resultIDs.has(id)) {\n      continue\n    }\n\n    const doc = await orama.documentsStore.get(docs, id)\n    const value = await getNested(doc as object, distinctOn)\n    if (typeof value === 'undefined' || values.has(value)) {\n      continue\n    }\n    values.set(value, true)\n\n    count++\n    // We shouldn't consider the document if it's not in the offset range\n    if (count <= offset) {\n      continue\n    }\n\n    results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc! })\n    resultIDs.add(id)\n\n    // reached the limit, break the loop\n    if (count >= offset + limit) {\n      break\n    }\n  }\n\n  return results\n}\n\nexport async function fetchDocuments<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  const results: Result<ResultDocument>[] = Array.from({\n    length: limit\n  })\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      break\n    }\n\n    const [id, score] = idAndScore\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = await orama.documentsStore.get(docs, id)\n      results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc! }\n      resultIDs.add(id)\n    }\n  }\n  return results\n}\n"],"names":["getDocumentIdFromInternalId","createError","getNested","MODE_FULLTEXT_SEARCH","MODE_HYBRID_SEARCH","MODE_VECTOR_SEARCH","fullTextSearch","searchVector","hybridSearch","defaultBM25Params","k","b","d","createSearchContext","tokenizer","index","documentsStore","language","params","properties","tokens","docsCount","timeStart","indexMap","docsIntersection","prop","tokensMap","token","uniqueDocsIDs","search","orama","mode","fetchDocumentsWithDistinct","uniqueDocsArray","offset","limit","distinctOn","docs","data","values","Map","results","resultIDs","Set","uniqueDocsArrayLength","length","count","i","idAndScore","id","score","has","doc","get","value","set","push","internalDocumentIDStore","document","add","fetchDocuments","Array","from","fullDoc"],"mappings":"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"}}]
}