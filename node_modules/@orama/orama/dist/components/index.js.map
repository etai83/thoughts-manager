{"version":3,"sources":["../../src/components/index.ts"],"sourcesContent":["import type {\n  AnyIndexStore,\n  AnyOrama,\n  ArraySearchableType,\n  BM25Params,\n  ComparisonOperator,\n  EnumArrComparisonOperator,\n  EnumComparisonOperator,\n  GeosearchOperation,\n  GeosearchPolygonOperator,\n  GeosearchRadiusOperator,\n  IIndex,\n  ScalarSearchableType,\n  SearchableType,\n  SearchableValue,\n  SearchContext,\n  SearchParamsFullText,\n  Tokenizer,\n  TokenScore,\n  TypedDocument,\n  VectorIndex,\n  VectorType,\n  WhereCondition\n} from '../types.js'\nimport type { InsertOptions } from '../methods/insert.js'\nimport { createError } from '../errors.js'\nimport {\n  create as avlCreate,\n  find as avlFind,\n  greaterThan as avlGreaterThan,\n  insert as avlInsert,\n  lessThan as avlLessThan,\n  RootNode as AVLRootNode,\n  rangeSearch as avlRangeSearch,\n  removeDocument as avlRemoveDocument\n} from '../trees/avl.js'\nimport {\n  create as flatCreate,\n  filter as flatFilter,\n  filterArr as flatFilterArr,\n  insert as flatInsert,\n  removeDocument as flatRemoveDocument,\n  FlatTree\n} from '../trees/flat.js'\nimport {\n  create as radixCreate,\n  find as radixFind,\n  insert as radixInsert,\n  Node as RadixNode,\n  removeDocumentByWord as radixRemoveDocument\n} from '../trees/radix.js'\nimport {\n  create as bkdCreate,\n  insert as bkdInsert,\n  removeDocByID as bkdRemoveDocByID,\n  RootNode as BKDNode,\n  Point as BKDGeoPoint,\n  searchByRadius,\n  searchByPolygon\n} from '../trees/bkd.js'\n\nimport { convertDistanceToMeters, intersect, safeArrayPush, getOwnProperty } from '../utils.js'\nimport { BM25 } from './algorithms.js'\nimport { getMagnitude } from './cosine-similarity.js'\nimport { getInnerType, getVectorSize, isArrayType, isVectorType } from './defaults.js'\nimport {\n  DocumentID,\n  getInternalDocumentId,\n  InternalDocumentID,\n  InternalDocumentIDStore\n} from './internal-document-id-store.js'\n\nexport type FrequencyMap = {\n  [property: string]: {\n    [documentID: InternalDocumentID]:\n      | {\n          [token: string]: number\n        }\n      | undefined\n  }\n}\n\nexport type BooleanIndex = {\n  true: InternalDocumentID[]\n  false: InternalDocumentID[]\n}\n\nexport type TreeType = 'AVL' | 'Radix' | 'Bool' | 'Flat' | 'BKD'\n\nexport type TTree<T = TreeType, N = unknown> = {\n  type: T\n  node: N\n  isArray: boolean\n}\n\nexport type Tree =\n  | TTree<'Radix', RadixNode>\n  | TTree<'AVL', AVLRootNode<number, InternalDocumentID[]>>\n  | TTree<'Bool', BooleanIndex>\n  | TTree<'Flat', FlatTree>\n  | TTree<'BKD', BKDNode>\n\nexport interface Index extends AnyIndexStore {\n  sharedInternalDocumentStore: InternalDocumentIDStore\n  indexes: Record<string, Tree>\n  vectorIndexes: Record<string, VectorIndex>\n  searchableProperties: string[]\n  searchablePropertiesWithTypes: Record<string, SearchableType>\n  frequencies: FrequencyMap\n  tokenOccurrences: Record<string, Record<string, number>>\n  avgFieldLength: Record<string, number>\n  fieldLengths: Record<string, Record<InternalDocumentID, number | undefined>>\n}\n\nexport async function insertDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  docsCount: number\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount\n  index.fieldLengths[prop][internalId] = tokens.length\n  index.frequencies[prop][internalId] = {}\n}\n\nexport async function insertTokenScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  tokens: string[],\n  token: string\n): Promise<void> {\n  let tokenFrequency = 0\n\n  for (const t of tokens) {\n    if (t === token) {\n      tokenFrequency++\n    }\n  }\n\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n  const tf = tokenFrequency / tokens.length\n\n  index.frequencies[prop][internalId]![token] = tf\n\n  if (!(token in index.tokenOccurrences[prop])) {\n    index.tokenOccurrences[prop][token] = 0\n  }\n\n  // increase a token counter that may not yet exist\n  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1\n}\n\nexport async function removeDocumentScoreParameters(\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  docsCount: number\n): Promise<void> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (docsCount > 1) {\n    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]!) / (docsCount - 1);\n  } else {\n    index.avgFieldLength[prop] = undefined as unknown as number;\n  }\n  index.fieldLengths[prop][internalId] = undefined\n  index.frequencies[prop][internalId] = undefined\n}\n\nexport async function removeTokenScoreParameters(index: Index, prop: string, token: string): Promise<void> {\n  index.tokenOccurrences[prop][token]--\n}\n\nexport async function calculateResultScores<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument, SearchParamsFullText<T, ResultDocument>>,\n  index: Index,\n  prop: string,\n  term: string,\n  ids: DocumentID[]\n): Promise<TokenScore[]> {\n  const documentIDs = Array.from(ids)\n\n  // Exact fields for TF-IDF\n  const avgFieldLength = index.avgFieldLength[prop]\n  const fieldLengths = index.fieldLengths[prop]\n  const oramaOccurrences = index.tokenOccurrences[prop]\n  const oramaFrequencies = index.frequencies[prop]\n\n  // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }\n  const termOccurrences = typeof oramaOccurrences[term] === 'number' ? oramaOccurrences[term] ?? 0 : 0\n\n  const scoreList: TokenScore[] = []\n\n  // Calculate TF-IDF value for each term, in each document, for each index.\n  const documentIDsLength = documentIDs.length\n  for (let k = 0; k < documentIDsLength; k++) {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, documentIDs[k])\n    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0\n\n    const bm25 = BM25(\n      tf,\n      termOccurrences,\n      context.docsCount,\n      fieldLengths[internalId]!,\n      avgFieldLength,\n      context.params.relevance! as Required<BM25Params>\n    )\n\n    scoreList.push([internalId, bm25])\n  }\n  return scoreList\n}\n\nexport async function create<T extends AnyOrama, TSchema extends T['schema']>(\n  orama: T,\n  sharedInternalDocumentStore: T['internalDocumentIDStore'],\n  schema: TSchema,\n  index?: Index,\n  prefix = ''\n): Promise<Index> {\n  if (!index) {\n    index = {\n      sharedInternalDocumentStore,\n      indexes: {},\n      vectorIndexes: {},\n      searchableProperties: [],\n      searchablePropertiesWithTypes: {},\n      frequencies: {},\n      tokenOccurrences: {},\n      avgFieldLength: {},\n      fieldLengths: {}\n    }\n  }\n\n  for (const [prop, type] of Object.entries<SearchableType>(schema)) {\n    const path = `${prefix}${prefix ? '.' : ''}${prop}`\n\n    if (typeof type === 'object' && !Array.isArray(type)) {\n      // Nested\n      create(orama, sharedInternalDocumentStore, type, index, path)\n      continue\n    }\n\n    if (isVectorType(type)) {\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n      index.vectorIndexes[path] = {\n        size: getVectorSize(type),\n        vectors: {}\n      }\n    } else {\n      const isArray = /\\[/.test(type as string)\n      switch (type) {\n        case 'boolean':\n        case 'boolean[]':\n          index.indexes[path] = { type: 'Bool', node: { true: [], false: [] }, isArray }\n          break\n        case 'number':\n        case 'number[]':\n          index.indexes[path] = { type: 'AVL', node: avlCreate<number, InternalDocumentID[]>(0, []), isArray }\n          break\n        case 'string':\n        case 'string[]':\n          index.indexes[path] = { type: 'Radix', node: radixCreate(), isArray }\n          index.avgFieldLength[path] = 0\n          index.frequencies[path] = {}\n          index.tokenOccurrences[path] = {}\n          index.fieldLengths[path] = {}\n          break\n        case 'enum':\n        case 'enum[]':\n          index.indexes[path] = { type: 'Flat', node: flatCreate(), isArray }\n          break\n        case 'geopoint':\n          index.indexes[path] = { type: 'BKD', node: bkdCreate(), isArray }\n          break\n        default:\n          throw createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path)\n      }\n\n      index.searchableProperties.push(path)\n      index.searchablePropertiesWithTypes[path] = type\n    }\n  }\n\n  return index\n}\n\nfunction insertScalarBuilder(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n  options?: InsertOptions\n) {\n  return async (value: SearchableValue): Promise<void> => {\n    const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n    const { type, node } = index.indexes[prop]\n    switch (type) {\n      case 'Bool': {\n        node[value ? 'true' : 'false'].push(internalId)\n        break\n      }\n      case 'AVL': {\n        const avlRebalanceThreshold = options?.avlRebalanceThreshold ?? 1\n        avlInsert(node, value as number, [internalId], avlRebalanceThreshold)\n        break\n      }\n      case 'Radix': {\n        const tokens = await tokenizer.tokenize(value as string, language, prop)\n        await implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount)\n\n        for (const token of tokens) {\n          await implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token)\n\n          radixInsert(node, token, internalId)\n        }\n\n        break\n      }\n      case 'Flat': {\n        flatInsert(node, value as ScalarSearchableType, internalId)\n        break\n      }\n      case 'BKD': {\n        bkdInsert(node, value as unknown as BKDGeoPoint, [internalId])\n        break\n      }\n    }\n  }\n}\n\nexport async function insert(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number,\n  options?: InsertOptions\n): Promise<void> {\n  if (isVectorType(schemaType)) {\n    return insertVector(index, prop, value as number[] | Float32Array, id)\n  }\n\n  const insertScalar = insertScalarBuilder(implementation, index, prop, id, language, tokenizer, docsCount, options)\n\n  if (!isArrayType(schemaType)) {\n    return insertScalar(value)\n  }\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await insertScalar(elements[i])\n  }\n}\n\nfunction insertVector(index: Index, prop: string, value: number[] | VectorType, id: DocumentID): void {\n  if (!(value instanceof Float32Array)) {\n    value = new Float32Array(value)\n  }\n\n  const size = index.vectorIndexes[prop].size\n  const magnitude = getMagnitude(value, size)\n\n  index.vectorIndexes[prop].vectors[id] = [magnitude, value]\n}\n\nasync function removeScalar(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: ScalarSearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number\n): Promise<boolean> {\n  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id)\n\n  if (isVectorType(schemaType)) {\n    delete index.vectorIndexes[prop].vectors[id]\n    return true\n  }\n\n  const { type, node } = index.indexes[prop]\n  switch (type) {\n    case 'AVL': {\n      avlRemoveDocument(node, internalId, value as number)\n      return true\n    }\n    case 'Bool': {\n      const booleanKey = value ? 'true' : 'false'\n      const position = node[booleanKey].indexOf(internalId)\n\n      node[value ? 'true' : 'false'].splice(position, 1)\n      return true\n    }\n    case 'Radix': {\n      const tokens = await tokenizer.tokenize(value as string, language, prop)\n\n      await implementation.removeDocumentScoreParameters(index, prop, id, docsCount)\n\n      for (const token of tokens) {\n        await implementation.removeTokenScoreParameters(index, prop, token)\n        radixRemoveDocument(node, token, internalId)\n      }\n\n      return true\n    }\n    case 'Flat': {\n      flatRemoveDocument(node, internalId, value as ScalarSearchableType)\n      return true\n    }\n    case 'BKD': {\n      bkdRemoveDocByID(node, value as unknown as BKDGeoPoint, internalId)\n      return false\n    }\n  }\n}\n\nexport async function remove(\n  implementation: IIndex<Index>,\n  index: Index,\n  prop: string,\n  id: DocumentID,\n  value: SearchableValue,\n  schemaType: SearchableType,\n  language: string | undefined,\n  tokenizer: Tokenizer,\n  docsCount: number\n): Promise<boolean> {\n  if (!isArrayType(schemaType)) {\n    return removeScalar(\n      implementation,\n      index,\n      prop,\n      id,\n      value,\n      schemaType as ScalarSearchableType,\n      language,\n      tokenizer,\n      docsCount\n    )\n  }\n\n  const innerSchemaType = getInnerType(schemaType as ArraySearchableType)\n\n  const elements = value as Array<string | number | boolean>\n  const elementsLength = elements.length\n  for (let i = 0; i < elementsLength; i++) {\n    await removeScalar(implementation, index, prop, id, elements[i], innerSchemaType, language, tokenizer, docsCount)\n  }\n\n  return true\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument, SearchParamsFullText<T, ResultDocument>>,\n  index: Index,\n  prop: string,\n  term: string\n): Promise<TokenScore[]> {\n  if (!(prop in index.tokenOccurrences)) {\n    return []\n  }\n\n  const { node, type } = index.indexes[prop]\n  if (type !== 'Radix') {\n    throw createError('WRONG_SEARCH_PROPERTY_TYPE', prop)\n  }\n\n  const { exact, tolerance } = context.params\n  const searchResult = radixFind(node, { term, exact, tolerance })\n  const ids = new Set<InternalDocumentID>()\n\n  for (const key in searchResult) {\n    //skip keys inherited from prototype\n    const ownProperty = getOwnProperty(searchResult, key)\n    if (!ownProperty) continue\n\n    for (const id of searchResult[key]) {\n      ids.add(id)\n    }\n  }\n\n  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids))\n}\n\nexport async function searchByWhereClause<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  context: SearchContext<T, ResultDocument>,\n  index: Index,\n  filters: Partial<WhereCondition<T['schema']>>\n): Promise<number[]> {\n  const filterKeys = Object.keys(filters)\n\n  const filtersMap: Record<string, InternalDocumentID[]> = filterKeys.reduce(\n    (acc, key) => ({\n      [key]: [],\n      ...acc\n    }),\n    {}\n  )\n\n  for (const param of filterKeys) {\n    const operation = filters[param]!\n\n    if (typeof index.indexes[param] === 'undefined') {\n      throw createError('UNKNOWN_FILTER_PROPERTY', param)\n    }\n\n    const { node, type, isArray } = index.indexes[param]\n\n    if (type === 'Bool') {\n      const idx = node\n      const filteredIDs = idx[operation.toString() as keyof BooleanIndex]\n      safeArrayPush(filtersMap[param], filteredIDs)\n      continue\n    }\n\n    if (type === 'BKD') {\n      let reqOperation: 'radius' | 'polygon'\n\n      if ('radius' in (operation as GeosearchOperation)) {\n        reqOperation = 'radius'\n      } else if ('polygon' in (operation as GeosearchOperation)) {\n        reqOperation = 'polygon'\n      } else {\n        throw new Error(`Invalid operation ${operation}`)\n      }\n\n      if (reqOperation === 'radius') {\n        const {\n          value,\n          coordinates,\n          unit = 'm',\n          inside = true,\n          highPrecision = false\n        } = operation[reqOperation] as GeosearchRadiusOperator['radius']\n        const distanceInMeters = convertDistanceToMeters(value, unit)\n        const ids = searchByRadius(\n          node.root,\n          coordinates as BKDGeoPoint,\n          distanceInMeters,\n          inside,\n          undefined,\n          highPrecision\n        )\n        // @todo: convert this into a for loop\n        safeArrayPush(\n          filtersMap[param],\n          ids.flatMap(({ docIDs }) => docIDs)\n        )\n      } else {\n        const {\n          coordinates,\n          inside = true,\n          highPrecision = false\n        } = operation[reqOperation] as GeosearchPolygonOperator['polygon']\n        const ids = searchByPolygon(node.root, coordinates as BKDGeoPoint[], inside, undefined, highPrecision)\n        // @todo: convert this into a for loop\n        safeArrayPush(\n          filtersMap[param],\n          ids.flatMap(({ docIDs }) => docIDs)\n        )\n      }\n\n      continue\n    }\n\n    if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {\n      for (const raw of [operation].flat()) {\n        const term = await context.tokenizer.tokenize(raw, context.language, param)\n        for (const t of term) {\n          const filteredIDsResults = radixFind(node, { term: t, exact: true })\n          safeArrayPush(filtersMap[param], Object.values(filteredIDsResults).flat())\n        }\n      }\n\n      continue\n    }\n\n    const operationKeys = Object.keys(operation)\n\n    if (operationKeys.length > 1) {\n      throw createError('INVALID_FILTER_OPERATION', operationKeys.length)\n    }\n\n    if (type === 'Flat') {\n      const flatOperation = isArray ? flatFilterArr : flatFilter\n      safeArrayPush(\n        filtersMap[param],\n        flatOperation(node, operation as EnumComparisonOperator & EnumArrComparisonOperator)\n      )\n\n      continue\n    }\n\n    if (type === 'AVL') {\n      const operationOpt = operationKeys[0] as keyof ComparisonOperator\n      const operationValue = (operation as ComparisonOperator)[operationOpt]\n      let filteredIDs: InternalDocumentID[] = []\n\n      switch (operationOpt) {\n        case 'gt': {\n          filteredIDs = avlGreaterThan(node, operationValue, false)\n          break\n        }\n        case 'gte': {\n          filteredIDs = avlGreaterThan(node, operationValue, true)\n          break\n        }\n        case 'lt': {\n          filteredIDs = avlLessThan(node, operationValue, false)\n          break\n        }\n        case 'lte': {\n          filteredIDs = avlLessThan(node, operationValue, true)\n          break\n        }\n        case 'eq': {\n          filteredIDs = avlFind(node, operationValue) ?? []\n          break\n        }\n        case 'between': {\n          const [min, max] = operationValue as number[]\n          filteredIDs = avlRangeSearch(node, min, max)\n          break\n        }\n      }\n\n      safeArrayPush(filtersMap[param], filteredIDs)\n    }\n  }\n\n  // AND operation: calculate the intersection between all the IDs in filterMap\n  return intersect(Object.values(filtersMap))\n}\n\nexport async function getSearchableProperties(index: Index): Promise<string[]> {\n  return index.searchableProperties\n}\n\nexport async function getSearchablePropertiesWithTypes(index: Index): Promise<Record<string, SearchableType>> {\n  return index.searchablePropertiesWithTypes\n}\n\nfunction loadRadixNode(node: RadixNode): RadixNode {\n  const convertedNode = radixCreate(node.e, node.s, node.k)\n\n  convertedNode.d = node.d\n  convertedNode.w = node.w\n\n  for (const childrenKey of Object.keys(node.c)) {\n    convertedNode.c[childrenKey] = loadRadixNode(node.c[childrenKey])\n  }\n\n  return convertedNode\n}\n\nfunction loadFlatNode(node: unknown): FlatTree {\n  return {\n    numberToDocumentId: new Map(node as [ScalarSearchableType, InternalDocumentID[]][])\n  }\n}\n\nfunction saveFlatNode(node: FlatTree): unknown {\n  return Array.from(node.numberToDocumentId.entries())\n}\n\nexport async function load<R = unknown>(sharedInternalDocumentStore: InternalDocumentIDStore, raw: R): Promise<Index> {\n  const {\n    indexes: rawIndexes,\n    vectorIndexes: rawVectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = raw as Index\n\n  const indexes: Index['indexes'] = {}\n  const vectorIndexes: Index['vectorIndexes'] = {}\n\n  for (const prop of Object.keys(rawIndexes)) {\n    const { node, type, isArray } = rawIndexes[prop]\n\n    switch (type) {\n      case 'Radix':\n        indexes[prop] = {\n          type: 'Radix',\n          node: loadRadixNode(node),\n          isArray\n        }\n        break\n      case 'Flat':\n        indexes[prop] = {\n          type: 'Flat',\n          node: loadFlatNode(node),\n          isArray\n        }\n        break\n      default:\n        indexes[prop] = rawIndexes[prop]\n    }\n  }\n\n  for (const idx of Object.keys(rawVectorIndexes)) {\n    const vectors = rawVectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], new Float32Array(vectors[vec][1])]\n    }\n\n    vectorIndexes[idx] = {\n      size: rawVectorIndexes[idx].size,\n      vectors\n    }\n  }\n\n  return {\n    sharedInternalDocumentStore,\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  }\n}\n\nexport async function save<R = unknown>(index: Index): Promise<R> {\n  const {\n    indexes,\n    vectorIndexes,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } = index\n\n  const vectorIndexesAsArrays: Index['vectorIndexes'] = {}\n\n  for (const idx of Object.keys(vectorIndexes)) {\n    const vectors = vectorIndexes[idx].vectors\n\n    for (const vec in vectors) {\n      vectors[vec] = [vectors[vec][0], Array.from(vectors[vec][1]) as unknown as Float32Array]\n    }\n\n    vectorIndexesAsArrays[idx] = {\n      size: vectorIndexes[idx].size,\n      vectors\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const savedIndexes: any = {}\n  for (const name of Object.keys(indexes)) {\n    const { type, node, isArray } = indexes[name]\n    if (type !== 'Flat') {\n      savedIndexes[name] = indexes[name]\n      continue\n    }\n    savedIndexes[name] = {\n      type: 'Flat',\n      node: saveFlatNode(node),\n      isArray\n    }\n  }\n\n  return {\n    indexes: savedIndexes,\n    vectorIndexes: vectorIndexesAsArrays,\n    searchableProperties,\n    searchablePropertiesWithTypes,\n    frequencies,\n    tokenOccurrences,\n    avgFieldLength,\n    fieldLengths\n  } as R\n}\n\nexport async function createIndex(): Promise<IIndex<Index>> {\n  return {\n    create,\n    insert,\n    remove,\n    insertDocumentScoreParameters,\n    insertTokenScoreParameters,\n    removeDocumentScoreParameters,\n    removeTokenScoreParameters,\n    calculateResultScores,\n    search,\n    searchByWhereClause,\n    getSearchableProperties,\n    getSearchablePropertiesWithTypes,\n    load,\n    save\n  }\n}\n"],"names":["createError","create","avlCreate","find","avlFind","greaterThan","avlGreaterThan","insert","avlInsert","lessThan","avlLessThan","rangeSearch","avlRangeSearch","removeDocument","avlRemoveDocument","flatCreate","filter","flatFilter","filterArr","flatFilterArr","flatInsert","flatRemoveDocument","radixCreate","radixFind","radixInsert","removeDocumentByWord","radixRemoveDocument","bkdCreate","bkdInsert","removeDocByID","bkdRemoveDocByID","searchByRadius","searchByPolygon","convertDistanceToMeters","intersect","safeArrayPush","getOwnProperty","BM25","getMagnitude","getInnerType","getVectorSize","isArrayType","isVectorType","getInternalDocumentId","insertDocumentScoreParameters","index","prop","id","tokens","docsCount","internalId","sharedInternalDocumentStore","avgFieldLength","length","fieldLengths","frequencies","insertTokenScoreParameters","token","tokenFrequency","t","tf","tokenOccurrences","removeDocumentScoreParameters","undefined","removeTokenScoreParameters","calculateResultScores","context","term","ids","documentIDs","Array","from","oramaOccurrences","oramaFrequencies","termOccurrences","scoreList","documentIDsLength","k","bm25","params","relevance","push","orama","schema","prefix","indexes","vectorIndexes","searchableProperties","searchablePropertiesWithTypes","type","Object","entries","path","isArray","size","vectors","test","node","true","false","insertScalarBuilder","implementation","language","tokenizer","options","value","avlRebalanceThreshold","tokenize","schemaType","insertVector","insertScalar","elements","elementsLength","i","Float32Array","magnitude","removeScalar","booleanKey","position","indexOf","splice","remove","innerSchemaType","search","exact","tolerance","searchResult","Set","key","ownProperty","add","searchByWhereClause","filters","filterKeys","keys","filtersMap","reduce","acc","param","operation","idx","filteredIDs","toString","reqOperation","Error","coordinates","unit","inside","highPrecision","distanceInMeters","root","flatMap","docIDs","raw","flat","filteredIDsResults","values","operationKeys","flatOperation","operationOpt","operationValue","min","max","getSearchableProperties","getSearchablePropertiesWithTypes","loadRadixNode","convertedNode","e","s","d","w","childrenKey","c","loadFlatNode","numberToDocumentId","Map","saveFlatNode","load","rawIndexes","rawVectorIndexes","vec","save","vectorIndexesAsArrays","savedIndexes","name","createIndex"],"mappings":"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"}