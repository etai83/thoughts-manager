{"version":3,"sources":["../../src/methods/search.ts"],"sourcesContent":["import { InternalDocumentID, getDocumentIdFromInternalId } from '../components/internal-document-id-store.js'\nimport { createError } from '../errors.js'\nimport { getNested } from '../utils.js'\nimport type {\n  AnyOrama,\n  BM25Params,\n  IndexMap,\n  LiteralUnion,\n  Result,\n  Results,\n  SearchContext,\n  SearchParams,\n  SearchParamsFullText,\n  SearchParamsHybrid,\n  SearchParamsVector,\n  SearchableValue,\n  TokenMap,\n  Tokenizer,\n  TypedDocument\n} from '../types.js'\nimport { MODE_FULLTEXT_SEARCH, MODE_HYBRID_SEARCH, MODE_VECTOR_SEARCH } from '../constants.js'\nimport { fullTextSearch } from './search-fulltext.js'\nimport { searchVector } from './search-vector.js'\nimport { hybridSearch } from './search-hybrid.js'\n\nexport const defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5\n}\n\nexport async function createSearchContext<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  tokenizer: Tokenizer,\n  index: T['index'],\n  documentsStore: T['documentsStore'],\n  language: string | undefined,\n  params: SearchParams<T, ResultDocument>,\n  properties: string[],\n  tokens: string[],\n  docsCount: number,\n  timeStart: bigint\n): Promise<SearchContext<T, ResultDocument>> {\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  // const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  // let whereFiltersIDs: string[] = [];\n\n  // if (hasFilters) {\n  //   whereFiltersIDs = getWhereFiltersIDs(params.where!, orama);\n  // }\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {}\n\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {}\n\n  for (const prop of properties) {\n    const tokensMap: TokenMap = {}\n    for (const token of tokens) {\n      tokensMap[token] = []\n    }\n    indexMap[prop] = tokensMap\n    docsIntersection[prop] = []\n  }\n\n  return {\n    timeStart,\n    tokenizer,\n    index,\n    documentsStore,\n    language,\n    params,\n    docsCount,\n    uniqueDocsIDs: {},\n    indexMap,\n    docsIntersection\n  }\n}\n\nexport async function search<T extends AnyOrama, ResultDocument = TypedDocument<T>>(\n  orama: T,\n  params: SearchParams<T, ResultDocument>,\n  language?: string\n): Promise<Results<ResultDocument>> {\n  const mode = params.mode ?? MODE_FULLTEXT_SEARCH\n\n  if (mode === MODE_FULLTEXT_SEARCH) {\n    return fullTextSearch(orama, params as SearchParamsFullText<T, ResultDocument>, language)\n  }\n\n  if (mode === MODE_VECTOR_SEARCH) {\n    return searchVector(orama, params as SearchParamsVector<T, ResultDocument>)\n  }\n\n  if (mode === MODE_HYBRID_SEARCH) {\n    return hybridSearch(orama, params as SearchParamsHybrid<T, ResultDocument>)\n  }\n\n  throw createError('INVALID_SEARCH_MODE', mode)\n}\n\nexport async function fetchDocumentsWithDistinct<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number,\n  distinctOn: LiteralUnion<T['schema']>\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  // Keep track which values we already seen\n  const values = new Map<SearchableValue, true>()\n\n  // We cannot know how many results we will have in the end,\n  // so we need cannot pre-allocate the array.\n  const results: Result<ResultDocument>[] = []\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n  const uniqueDocsArrayLength = uniqueDocsArray.length\n  let count = 0\n  for (let i = 0; i < uniqueDocsArrayLength; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      continue\n    }\n\n    const [id, score] = idAndScore\n\n    if (resultIDs.has(id)) {\n      continue\n    }\n\n    const doc = await orama.documentsStore.get(docs, id)\n    const value = await getNested(doc as object, distinctOn)\n    if (typeof value === 'undefined' || values.has(value)) {\n      continue\n    }\n    values.set(value, true)\n\n    count++\n    // We shouldn't consider the document if it's not in the offset range\n    if (count <= offset) {\n      continue\n    }\n\n    results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc! })\n    resultIDs.add(id)\n\n    // reached the limit, break the loop\n    if (count >= offset + limit) {\n      break\n    }\n  }\n\n  return results\n}\n\nexport async function fetchDocuments<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  orama: T,\n  uniqueDocsArray: [InternalDocumentID, number][],\n  offset: number,\n  limit: number\n): Promise<Result<ResultDocument>[]> {\n  const docs = orama.data.docs\n\n  const results: Result<ResultDocument>[] = Array.from({\n    length: limit\n  })\n\n  const resultIDs: Set<InternalDocumentID> = new Set()\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i]\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === 'undefined') {\n      break\n    }\n\n    const [id, score] = idAndScore\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = await orama.documentsStore.get(docs, id)\n      results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc! }\n      resultIDs.add(id)\n    }\n  }\n  return results\n}\n"],"names":["getDocumentIdFromInternalId","createError","getNested","MODE_FULLTEXT_SEARCH","MODE_HYBRID_SEARCH","MODE_VECTOR_SEARCH","fullTextSearch","searchVector","hybridSearch","defaultBM25Params","k","b","d","createSearchContext","tokenizer","index","documentsStore","language","params","properties","tokens","docsCount","timeStart","indexMap","docsIntersection","prop","tokensMap","token","uniqueDocsIDs","search","orama","mode","fetchDocumentsWithDistinct","uniqueDocsArray","offset","limit","distinctOn","docs","data","values","Map","results","resultIDs","Set","uniqueDocsArrayLength","length","count","i","idAndScore","id","score","has","doc","get","value","set","push","internalDocumentIDStore","document","add","fetchDocuments","Array","from","fullDoc"],"mappings":"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"}